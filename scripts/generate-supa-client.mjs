import fs from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const projectRoot = path.resolve(__dirname, '..');
const GENERATED_BANNER = "// This file is generated by scripts/generate-supa-client.mjs\n";
const DEFAULT_CREDENTIALS_PATH = path.join(projectRoot, 'supabase', 'defaultCredentials.json');
const SUPABASE_URL_KEYS = ['VITE_SUPABASE_URL', 'NEXT_PUBLIC_SUPABASE_URL'];
const SUPABASE_ANON_KEYS = ['VITE_SUPABASE_ANON_KEY', 'NEXT_PUBLIC_SUPABASE_ANON_KEY'];
const SUPABASE_REDIRECT_KEYS = ['VITE_SUPABASE_REDIRECT_URL', 'NEXT_PUBLIC_SUPABASE_REDIRECT_URL'];

async function fileExists(filePath) {
  try {
    await fs.access(filePath);
    return true;
  } catch (error) {
    if (error?.code === 'ENOENT') return false;
    throw error;
  }
}

async function loadProjectEnv() {
  const envLoadPlan = [
    { file: '.env', overrideExisting: false },
    { file: '.env.local', overrideExisting: true },
  ];

  for (const { file, overrideExisting } of envLoadPlan) {
    const envPath = path.join(projectRoot, file);
    if (await fileExists(envPath)) {
      await loadEnvFile(envPath, { overrideExisting });
    }
  }
}

async function loadDefaultCredentials() {
  if (!(await fileExists(DEFAULT_CREDENTIALS_PATH))) {
    return { url: null, anonKey: null };
  }
  const source = await fs.readFile(DEFAULT_CREDENTIALS_PATH, 'utf8');
  try {
    const parsed = JSON.parse(source);
    return {
      url: parsed?.url?.trim() || null,
      anonKey: parsed?.anonKey?.trim() || null,
    };
  } catch (error) {
    throw new Error(`Invalid JSON in ${path.relative(projectRoot, DEFAULT_CREDENTIALS_PATH)}: ${error.message}`);
  }
}

async function loadEnvFile(envPath, { overrideExisting }) {
  const source = await fs.readFile(envPath, 'utf8');
  const lines = source.split(/\r?\n/);
  for (const rawLine of lines) {
    const line = rawLine.trim();
    if (!line || line.startsWith('#')) continue;
    const equalsIndex = line.indexOf('=');
    if (equalsIndex === -1) continue;
    const key = line.slice(0, equalsIndex).trim();
    if (!key) continue;
    let value = line.slice(equalsIndex + 1).trim();
    if (value.startsWith('"') && value.endsWith('"')) {
      value = value.slice(1, -1);
    } else if (value.startsWith("'") && value.endsWith("'")) {
      value = value.slice(1, -1);
    }
    if (overrideExisting || process.env[key] === undefined) {
      process.env[key] = value;
    }
  }
}

function getEnvValue(keys) {
  for (const key of keys) {
    const value = process.env[key];
    if (typeof value === 'string' && value.trim()) {
      return value.trim();
    }
  }
  return null;
}

function createSupaClientSource({ url, anonKey, redirectUrl }) {
  const serializedUrl = JSON.stringify(url ?? '');
  const serializedAnonKey = JSON.stringify(anonKey ?? '');
  const serializedRedirect = redirectUrl ? JSON.stringify(redirectUrl) : 'null';
  const fallbackRedirectExpression = '${window.location.origin}${DEFAULT_AUTH_CALLBACK_PATH}';

  return `${GENERATED_BANNER}import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const SUPABASE_URL = ${serializedUrl};
const SUPABASE_ANON_KEY = ${serializedAnonKey};
const DEFAULT_AUTH_CALLBACK_PATH = '/auth/callback';

export function getSupabaseRedirectUrl() {
  const configuredRedirect = ${serializedRedirect};
  if (configuredRedirect) {
    return configuredRedirect;
  }
  if (typeof window !== 'undefined' && window.location?.origin) {
    return \`${fallbackRedirectExpression}\`;
  }
  return null;
}

if (!SUPABASE_URL || !SUPABASE_ANON_KEY) {
  throw new Error(
    'Supabase credentials are missing. Set VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY before running the build.',
  );
}

export const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

if (typeof window !== 'undefined') {
  window.__LIFEGOAL_SUPABASE_REDIRECT_URL__ = getSupabaseRedirectUrl();
}
`;
}

async function main() {
  await loadProjectEnv();
  const defaultCredentials = await loadDefaultCredentials();

  const supabaseUrl = getEnvValue(SUPABASE_URL_KEYS) || defaultCredentials.url;
  const supabaseAnonKey = getEnvValue(SUPABASE_ANON_KEYS) || defaultCredentials.anonKey;
  const supabaseRedirect = getEnvValue(SUPABASE_REDIRECT_KEYS);

  const outputPath = path.join(projectRoot, 'public', 'assets', 'supaClient.js');
  const nextSource = createSupaClientSource({
    url: supabaseUrl,
    anonKey: supabaseAnonKey,
    redirectUrl: supabaseRedirect || null,
  });

  let shouldWrite = true;
  if (await fileExists(outputPath)) {
    const currentSource = await fs.readFile(outputPath, 'utf8');
    if (currentSource === nextSource) {
      shouldWrite = false;
    }
  }

  if (shouldWrite) {
    await fs.writeFile(outputPath, nextSource, 'utf8');
    console.log(`Generated Supabase client at ${path.relative(projectRoot, outputPath)}`);
  } else {
    console.log('Supabase client is up to date.');
  }
}

main().catch((error) => {
  console.error('Failed to generate public Supabase client.');
  console.error(error);
  process.exitCode = 1;
});
