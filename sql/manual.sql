-- Auto-generated manual bundle
-- Source: supabase/migrations/*.sql
-- Do not edit this file by hand.
-- Last generated: 2026-01-24T08:09:17.716Z

-- === BEGIN MIGRATION: 0001_habits_core.sql ===
-- ========================================================
-- HABITS MODULE - CORE SCHEMA
-- Migration 0001: Habits, Logs, Reminders, Profiles, Streaks
-- ========================================================

-- PROFILES TABLE (for user timezone and display name)
create table if not exists public.profiles (
  user_id uuid primary key references auth.users(id) on delete cascade,
  created_at timestamptz default now(),
  display_name text,
  tz text default 'UTC'
);

-- HABIT TYPE ENUM
do $$ begin
  create type habit_type as enum ('boolean','quantity','duration');
exception
  when duplicate_object then null;
end $$;

-- HABITS TABLE (enhanced version with new fields)
-- Note: We'll check if columns exist before adding to avoid conflicts with existing habits table
do $$
begin
  -- Check if we need to extend the existing habits table or create a new one
  if not exists (select 1 from information_schema.tables where table_schema = 'public' and table_name = 'habits_v2') then
    create table public.habits_v2 (
      id uuid primary key default gen_random_uuid(),
      user_id uuid not null references auth.users(id) on delete cascade,
      title text not null,
      emoji text,
      type habit_type not null default 'boolean',
      target_num numeric,
      target_unit text,
      schedule jsonb not null,
      allow_skip boolean default true,
      start_date date default current_date,
      archived boolean default false,
      created_at timestamptz default now(),
      autoprog jsonb -- For auto-progression config
    );
  end if;
end $$;

-- HABIT REMINDERS TABLE
create table if not exists public.habit_reminders (
  id uuid primary key default gen_random_uuid(),
  habit_id uuid not null,
  local_time time not null,
  days int[] default null,
  geo jsonb,
  created_at timestamptz default now()
);

-- Add foreign key constraint with proper check
do $$
begin
  if exists (select 1 from information_schema.tables where table_schema = 'public' and table_name = 'habits_v2') then
    if not exists (
      select 1 from information_schema.table_constraints 
      where constraint_name = 'habit_reminders_habit_id_fkey_v2' 
      and table_name = 'habit_reminders'
    ) then
      alter table public.habit_reminders add constraint habit_reminders_habit_id_fkey_v2 
        foreign key (habit_id) references public.habits_v2(id) on delete cascade;
    end if;
  end if;
end $$;

-- HABIT LOGS TABLE (enhanced version)
do $$
begin
  if not exists (select 1 from information_schema.tables where table_schema = 'public' and table_name = 'habit_logs_v2') then
    create table public.habit_logs_v2 (
      id uuid primary key default gen_random_uuid(),
      habit_id uuid not null references public.habits_v2(id) on delete cascade,
      user_id uuid not null references auth.users(id) on delete cascade,
      ts timestamptz not null default now(),
      date date not null,
      value numeric,
      done boolean not null default true,
      note text,
      mood int check (mood between 1 and 5)
    );

    create index idx_habit_logs_v2_habit_date on public.habit_logs_v2(habit_id, date);
    create index idx_habit_logs_v2_user_date on public.habit_logs_v2(user_id, date);
  end if;
end $$;

do $$
begin
  if exists (
    select 1 from information_schema.columns
    where table_schema = 'public'
      and table_name = 'habit_logs_v2'
      and column_name = 'date'
  ) then
    begin
      execute 'alter table public.habit_logs_v2 alter column date drop expression';
    exception
      when others then null;
    end;

    alter table public.habit_logs_v2
      alter column date set default ((timezone('UTC', now()))::date);
  end if;
end $$;

create or replace function public.set_habit_logs_v2_date()
returns trigger language plpgsql as $$
begin
  if new.ts is null then
    new.ts := now();
  end if;
  new.date := (timezone('UTC', new.ts)::date);
  return new;
end;
$$;

drop trigger if exists habit_logs_v2_set_date on public.habit_logs_v2;
create trigger habit_logs_v2_set_date
before insert or update on public.habit_logs_v2
for each row execute function public.set_habit_logs_v2_date();

-- STREAKS VIEW
create or replace view public.v_habit_streaks as
with daily as (
  select h.id habit_id, l.date, bool_or(l.done) as done
  from habits_v2 h
  left join habit_logs_v2 l on l.habit_id = h.id
  group by h.id, l.date
), gaps as (
  select habit_id, date, date - (row_number() over (partition by habit_id order by date))::int grp
  from daily where done is true
)
select habit_id,
       coalesce( (select count(*) from gaps g2
                  where g2.habit_id=g.habit_id
                    and g2.grp=(select max(grp) from gaps g3 where g3.habit_id=g.habit_id)), 0)::int as current_streak,
       coalesce( (select max(cnt) from (
                   select count(*) cnt from gaps g4 where g4.habit_id=g.habit_id group by grp
                 ) s), 0)::int as best_streak
from gaps g
group by habit_id;

-- RLS POLICIES
alter table public.habits_v2 enable row level security;
alter table public.habit_logs_v2 enable row level security;
alter table public.habit_reminders enable row level security;
alter table public.profiles enable row level security;

-- Profiles policies
drop policy if exists "own profiles" on public.profiles;
create policy "own profiles" on public.profiles
  for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

-- Habits policies
drop policy if exists "own habits v2" on public.habits_v2;
create policy "own habits v2" on public.habits_v2
  for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

-- Logs policies
drop policy if exists "own logs v2" on public.habit_logs_v2;
create policy "own logs v2" on public.habit_logs_v2
  for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

-- Reminders policies
drop policy if exists "own reminders v2" on public.habit_reminders;
create policy "own reminders v2" on public.habit_reminders
  for all using (
    exists (select 1 from habits_v2 where id = habit_id and user_id = auth.uid())
  )
  with check (
    exists (select 1 from habits_v2 where id = habit_id and user_id = auth.uid())
  );
-- === END MIGRATION: 0001_habits_core.sql ===

-- === BEGIN MIGRATION: 0002_push.sql ===
-- ========================================================
-- HABITS MODULE - WEB PUSH NOTIFICATIONS
-- Migration 0002: Push Subscriptions
-- ========================================================

-- PUSH SUBSCRIPTIONS TABLE
create table if not exists public.push_subscriptions (
  user_id uuid not null references auth.users(id) on delete cascade,
  endpoint text primary key,
  p256dh text not null,
  auth text not null,
  created_at timestamptz default now()
);

-- RLS
alter table public.push_subscriptions enable row level security;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'push_subscriptions'
      and policyname = 'own push'
  ) then
    execute $pol$
      create policy "own push" on public.push_subscriptions
        for all using (auth.uid() = user_id) with check (auth.uid() = user_id);
    $pol$;
  end if;
end$$ language plpgsql;
-- === END MIGRATION: 0002_push.sql ===

-- === BEGIN MIGRATION: 0003_challenges_autoprog.sql ===
-- ========================================================
-- HABITS MODULE - CHALLENGES & AUTO-PROGRESSION
-- Migration 0003: Challenges, Leaderboard, Auto-Progression
-- ========================================================

-- CHALLENGES TABLE
create table if not exists public.habit_challenges (
  id uuid primary key default gen_random_uuid(),
  owner_id uuid not null references auth.users(id) on delete cascade,
  title text not null,
  description text,
  start_date date not null,
  end_date date not null,
  scoring text not null default 'count', -- 'count' = #days done; 'sum' = sum(value)
  created_at timestamptz default now()
);

-- CHALLENGE MEMBERS TABLE
create table if not exists public.habit_challenge_members (
  id uuid primary key default gen_random_uuid(),
  challenge_id uuid not null references public.habit_challenges(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  habit_id uuid, -- optional link to a specific habit (references habits_v2)
  joined_at timestamptz default now(),
  unique (challenge_id, user_id)
);

-- Add foreign key for habit_id if habits_v2 exists
do $$
begin
  if exists (select 1 from information_schema.tables where table_schema = 'public' and table_name = 'habits_v2') then
    if not exists (
      select 1 from information_schema.table_constraints 
      where constraint_name = 'habit_challenge_members_habit_id_fkey' 
      and table_name = 'habit_challenge_members'
    ) then
      alter table public.habit_challenge_members add constraint habit_challenge_members_habit_id_fkey 
        foreign key (habit_id) references public.habits_v2(id) on delete set null;
    end if;
  end if;
end $$;

-- CHALLENGE LEADERBOARD VIEW
create or replace view public.v_challenge_scores as
select m.challenge_id,
       m.user_id,
       p.display_name as user_display_name,
       coalesce(
         case c.scoring
           when 'sum' then (select sum(value) from habit_logs_v2 l
                            where l.user_id=m.user_id
                              and (m.habit_id is null or l.habit_id=m.habit_id)
                              and l.date between c.start_date and c.end_date)
           else (select count(distinct l.date) from habit_logs_v2 l
                 where l.user_id=m.user_id
                   and (m.habit_id is null or l.habit_id=m.habit_id)
                   and l.done is true
                   and l.date between c.start_date and c.end_date)
         end
       ,0)::numeric as score
from habit_challenge_members m
join habit_challenges c on c.id=m.challenge_id
left join profiles p on p.user_id = m.user_id;

-- RLS
alter table public.habit_challenges enable row level security;
alter table public.habit_challenge_members enable row level security;

-- Challenge policies
drop policy if exists "owner or member read challenge" on public.habit_challenges;
create policy "owner or member read challenge" on public.habit_challenges
  for select using (
    auth.uid() = owner_id
    or exists(select 1 from habit_challenge_members m where m.challenge_id = habit_challenges.id and m.user_id = auth.uid())
  );

drop policy if exists "owner write challenge" on public.habit_challenges;
create policy "owner write challenge" on public.habit_challenges
  for all using (auth.uid() = owner_id) with check (auth.uid() = owner_id);

-- Member policies
drop policy if exists "member read" on public.habit_challenge_members;
create policy "member read" on public.habit_challenge_members
  for select using (
    auth.uid() = user_id 
    or auth.uid() = (select owner_id from habit_challenges where id=challenge_id)
  );

drop policy if exists "self upsert" on public.habit_challenge_members;
create policy "self upsert" on public.habit_challenge_members
  for insert with check (auth.uid() = user_id);

drop policy if exists "self delete" on public.habit_challenge_members;
create policy "self delete" on public.habit_challenge_members
  for delete using (
    auth.uid() = user_id 
    or auth.uid() = (select owner_id from habit_challenges where id=challenge_id)
  );
-- === END MIGRATION: 0003_challenges_autoprog.sql ===

-- === BEGIN MIGRATION: 0004_habits_v2_domain_goal.sql ===
-- ========================================================
-- HABITS MODULE - DOMAIN/GOAL COLUMNS
-- Migration 0004: Add domain_key and goal_id to habits_v2
-- 
-- Purpose: Support dashboard quick-add parity by adding
-- domain_key (life wheel category) and goal_id (linked goal)
-- columns to the unified habits_v2 table.
-- ========================================================

-- Add domain_key column if not exists
-- This links the habit to a life wheel domain/category
ALTER TABLE public.habits_v2 ADD COLUMN IF NOT EXISTS domain_key text;

-- Add goal_id column if not exists
-- This links the habit to a specific goal
ALTER TABLE public.habits_v2 ADD COLUMN IF NOT EXISTS goal_id uuid REFERENCES public.goals(id) ON DELETE SET NULL;

-- Create index on domain_key for faster filtering by domain
CREATE INDEX IF NOT EXISTS habits_v2_domain_key_idx ON public.habits_v2(domain_key);

-- Create index on goal_id for faster filtering by linked goal
CREATE INDEX IF NOT EXISTS habits_v2_goal_id_idx ON public.habits_v2(goal_id);
-- === END MIGRATION: 0004_habits_v2_domain_goal.sql ===

-- === BEGIN MIGRATION: 0005_habit_adjustments.sql ===
-- Migration: Add habit_adjustments table for storing performance classification suggestions
-- This table is optional and used for auditing suggestion history.
-- If this table doesn't exist, the application will gracefully no-op persistence operations.

CREATE TABLE IF NOT EXISTS public.habit_adjustments (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  habit_id uuid REFERENCES public.habits_v2(id) ON DELETE CASCADE,
  created_at timestamptz DEFAULT now(),
  classification text,
  suggested_action text,
  rationale text,
  old_schedule jsonb,
  new_schedule jsonb,
  old_target_num numeric,
  new_target_num numeric,
  applied boolean DEFAULT false
);

CREATE INDEX IF NOT EXISTS habit_adjustments_habit_id_idx ON public.habit_adjustments(habit_id);
-- === END MIGRATION: 0005_habit_adjustments.sql ===

-- === BEGIN MIGRATION: 0006_habit_adjustments_rollbacks.sql ===
-- Migration: Add rollback/revert support columns to habit_adjustments table
-- This migration adds audit fields for tracking when suggestions are applied and reverted.

-- Add applied_at column (timestamp when the suggestion was applied)
ALTER TABLE public.habit_adjustments ADD COLUMN IF NOT EXISTS applied_at timestamptz;

-- Add reverted column (flag indicating if the suggestion has been rolled back)
ALTER TABLE public.habit_adjustments ADD COLUMN IF NOT EXISTS reverted boolean DEFAULT false;

-- Add reverted_at column (timestamp when the suggestion was reverted)
ALTER TABLE public.habit_adjustments ADD COLUMN IF NOT EXISTS reverted_at timestamptz;

-- Add revert_rationale column (optional user-provided reason for reverting)
ALTER TABLE public.habit_adjustments ADD COLUMN IF NOT EXISTS revert_rationale text;

-- Note: For existing applied rows without applied_at, the service layer will backfill
-- applied_at = now() on first revert operation via COALESCE(applied_at, now()).
-- === END MIGRATION: 0006_habit_adjustments_rollbacks.sql ===

-- === BEGIN MIGRATION: 0007_reminder_prefs_and_state.sql ===
-- ========================================================
-- DAILY REMINDER SCHEDULING - USER PREFERENCES & STATE
-- Migration 0007: Per-user reminder preferences and habit reminder state
-- ========================================================

-- USER REMINDER PREFERENCES TABLE
-- Stores per-user timezone and daily reminder window settings
CREATE TABLE IF NOT EXISTS public.user_reminder_prefs (
  user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  timezone TEXT NOT NULL DEFAULT 'UTC',
  window_start TIME NOT NULL DEFAULT '08:00:00',
  window_end TIME NOT NULL DEFAULT '10:00:00',
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- HABIT REMINDER STATE TABLE
-- Tracks idempotent delivery to prevent duplicate reminders
CREATE TABLE IF NOT EXISTS public.habit_reminder_state (
  habit_id UUID PRIMARY KEY REFERENCES public.habits_v2(id) ON DELETE CASCADE,
  last_reminder_sent_at TIMESTAMPTZ,
  snooze_until TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- INDEXES
-- Index on user_id for fast lookups in user_reminder_prefs
CREATE INDEX IF NOT EXISTS idx_user_reminder_prefs_user_id 
  ON public.user_reminder_prefs(user_id);

-- Index on last_reminder_sent_at for efficient filtering of recently-reminded habits
CREATE INDEX IF NOT EXISTS idx_habit_reminder_state_last_sent 
  ON public.habit_reminder_state(last_reminder_sent_at);

-- Index on snooze_until for filtering snoozed habits
CREATE INDEX IF NOT EXISTS idx_habit_reminder_state_snooze 
  ON public.habit_reminder_state(snooze_until);

-- ROW LEVEL SECURITY
ALTER TABLE public.user_reminder_prefs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.habit_reminder_state ENABLE ROW LEVEL SECURITY;

-- USER REMINDER PREFS POLICIES
-- Users can only access and modify their own reminder preferences
DROP POLICY IF EXISTS "own_reminder_prefs" ON public.user_reminder_prefs;
CREATE POLICY "own_reminder_prefs" ON public.user_reminder_prefs
  FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

-- HABIT REMINDER STATE POLICIES
-- Users can only access reminder state for habits they own
DROP POLICY IF EXISTS "own_habit_reminder_state" ON public.habit_reminder_state;
CREATE POLICY "own_habit_reminder_state" ON public.habit_reminder_state
  FOR ALL USING (
    EXISTS (SELECT 1 FROM public.habits_v2 WHERE id = habit_id AND user_id = auth.uid())
  )
  WITH CHECK (
    EXISTS (SELECT 1 FROM public.habits_v2 WHERE id = habit_id AND user_id = auth.uid())
  );

-- UPDATED_AT TRIGGER FUNCTIONS
CREATE OR REPLACE FUNCTION public.set_user_reminder_prefs_updated_at()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN
  NEW.updated_at := now();
  RETURN NEW;
END;
$$;

CREATE OR REPLACE FUNCTION public.set_habit_reminder_state_updated_at()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN
  NEW.updated_at := now();
  RETURN NEW;
END;
$$;

-- UPDATED_AT TRIGGERS
DROP TRIGGER IF EXISTS user_reminder_prefs_updated_at ON public.user_reminder_prefs;
CREATE TRIGGER user_reminder_prefs_updated_at
  BEFORE UPDATE ON public.user_reminder_prefs
  FOR EACH ROW EXECUTE FUNCTION public.set_user_reminder_prefs_updated_at();

DROP TRIGGER IF EXISTS habit_reminder_state_updated_at ON public.habit_reminder_state;
CREATE TRIGGER habit_reminder_state_updated_at
  BEFORE UPDATE ON public.habit_reminder_state
  FOR EACH ROW EXECUTE FUNCTION public.set_habit_reminder_state_updated_at();
-- === END MIGRATION: 0007_reminder_prefs_and_state.sql ===

-- === BEGIN MIGRATION: 0008_per_habit_prefs_actions_logging.sql ===
-- ========================================================
-- PER-HABIT REMINDER PREFS, ACTION LOGS, AND DELIVERY FAILURES
-- Migration 0008: Actionable notifications, per-habit controls, delivery reliability
-- ========================================================

-- HABIT REMINDER PREFS TABLE
-- Stores per-habit reminder preferences (enable/disable, preferred time)
CREATE TABLE IF NOT EXISTS public.habit_reminder_prefs (
  habit_id UUID PRIMARY KEY REFERENCES public.habits_v2(id) ON DELETE CASCADE,
  enabled BOOLEAN NOT NULL DEFAULT true,
  preferred_time TIME NULL, -- optional per-habit preferred reminder time
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- REMINDER ACTION LOGS TABLE
-- Logs notification interactions (done, snooze, dismiss)
CREATE TABLE IF NOT EXISTS public.reminder_action_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  habit_id UUID NOT NULL REFERENCES public.habits_v2(id) ON DELETE CASCADE,
  action TEXT NOT NULL CHECK (action IN ('done', 'snooze', 'dismiss')),
  payload JSONB NULL,
  created_at TIMESTAMPTZ DEFAULT now()
);

-- REMINDER DELIVERY FAILURES TABLE (Dead-letter queue)
-- Logs persistent push notification delivery failures
CREATE TABLE IF NOT EXISTS public.reminder_delivery_failures (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  habit_id UUID NOT NULL REFERENCES public.habits_v2(id) ON DELETE CASCADE,
  endpoint TEXT NOT NULL,
  error TEXT NOT NULL,
  retry_count INT DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT now()
);

-- INDEXES
-- habit_reminder_prefs indexes
CREATE INDEX IF NOT EXISTS idx_habit_reminder_prefs_habit_id
  ON public.habit_reminder_prefs(habit_id);

-- reminder_action_logs indexes
CREATE INDEX IF NOT EXISTS idx_reminder_action_logs_user_id
  ON public.reminder_action_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_reminder_action_logs_habit_id
  ON public.reminder_action_logs(habit_id);
CREATE INDEX IF NOT EXISTS idx_reminder_action_logs_created_at
  ON public.reminder_action_logs(created_at);

-- reminder_delivery_failures indexes
CREATE INDEX IF NOT EXISTS idx_reminder_delivery_failures_user_id
  ON public.reminder_delivery_failures(user_id);
CREATE INDEX IF NOT EXISTS idx_reminder_delivery_failures_created_at
  ON public.reminder_delivery_failures(created_at);

-- ROW LEVEL SECURITY
ALTER TABLE public.habit_reminder_prefs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.reminder_action_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.reminder_delivery_failures ENABLE ROW LEVEL SECURITY;

-- HABIT REMINDER PREFS POLICIES
-- Users can read/write per-habit prefs for habits they own
DROP POLICY IF EXISTS "own_habit_reminder_prefs" ON public.habit_reminder_prefs;
CREATE POLICY "own_habit_reminder_prefs" ON public.habit_reminder_prefs
  FOR ALL USING (
    EXISTS (SELECT 1 FROM public.habits_v2 WHERE id = habit_id AND user_id = auth.uid())
  )
  WITH CHECK (
    EXISTS (SELECT 1 FROM public.habits_v2 WHERE id = habit_id AND user_id = auth.uid())
  );

-- REMINDER ACTION LOGS POLICIES
-- Users can read their own logs; inserts allowed via service role or own user
DROP POLICY IF EXISTS "own_reminder_action_logs_select" ON public.reminder_action_logs;
CREATE POLICY "own_reminder_action_logs_select" ON public.reminder_action_logs
  FOR SELECT USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "own_reminder_action_logs_insert" ON public.reminder_action_logs;
CREATE POLICY "own_reminder_action_logs_insert" ON public.reminder_action_logs
  FOR INSERT WITH CHECK (auth.uid() = user_id);

-- REMINDER DELIVERY FAILURES POLICIES
-- Users can read their own failure logs; inserts are service-role only
DROP POLICY IF EXISTS "own_reminder_delivery_failures_select" ON public.reminder_delivery_failures;
CREATE POLICY "own_reminder_delivery_failures_select" ON public.reminder_delivery_failures
  FOR SELECT USING (auth.uid() = user_id);

-- Service role bypass for inserts (service role has full access by default)
-- No additional policy needed for service role inserts

-- UPDATED_AT TRIGGER FUNCTIONS
CREATE OR REPLACE FUNCTION public.set_habit_reminder_prefs_updated_at()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN
  NEW.updated_at := now();
  RETURN NEW;
END;
$$;

-- UPDATED_AT TRIGGERS
DROP TRIGGER IF EXISTS habit_reminder_prefs_updated_at ON public.habit_reminder_prefs;
CREATE TRIGGER habit_reminder_prefs_updated_at
  BEFORE UPDATE ON public.habit_reminder_prefs
  FOR EACH ROW EXECUTE FUNCTION public.set_habit_reminder_prefs_updated_at();
-- === END MIGRATION: 0008_per_habit_prefs_actions_logging.sql ===

-- === BEGIN MIGRATION: 0009_reminder_analytics_views.sql ===
-- ========================================================
-- REMINDER ANALYTICS VIEWS
-- Migration 0009: Analytics layer for reminder effectiveness tracking
-- ========================================================

-- VIEW: reminder_actions_daily
-- Aggregates reminder action logs by day, user, habit, and action type
CREATE OR REPLACE VIEW public.reminder_actions_daily AS
SELECT 
  date_trunc('day', created_at)::date AS day,
  user_id,
  habit_id,
  action,
  count(*) AS action_count
FROM public.reminder_action_logs
GROUP BY 1, 2, 3, 4;

-- VIEW: reminder_sends_daily
-- Approximates daily reminder sends from habit_reminder_state (last_reminder_sent_at)
-- This tracks distinct habit reminders sent per user per day
CREATE OR REPLACE VIEW public.reminder_sends_daily AS
SELECT 
  date_trunc('day', last_reminder_sent_at)::date AS day,
  h.user_id,
  hrs.habit_id,
  1 AS sends
FROM public.habit_reminder_state hrs
INNER JOIN public.habits_v2 h ON h.id = hrs.habit_id
WHERE hrs.last_reminder_sent_at IS NOT NULL;

-- VIEW: reminder_failures_daily
-- Aggregates delivery failures by day and user
CREATE OR REPLACE VIEW public.reminder_failures_daily AS
SELECT 
  date_trunc('day', created_at)::date AS day,
  user_id,
  count(*) AS failures
FROM public.reminder_delivery_failures
GROUP BY 1, 2;

-- MATERIALIZED VIEW: reminder_metrics_aggregate_30d
-- Pre-aggregated 30-day metrics per user for efficient dashboard queries
-- Note: Requires periodic refresh via REFRESH MATERIALIZED VIEW CONCURRENTLY
CREATE MATERIALIZED VIEW IF NOT EXISTS public.reminder_metrics_aggregate_30d AS
WITH date_range AS (
  SELECT 
    current_date - interval '30 days' AS start_date,
    current_date AS end_date
),
user_sends AS (
  SELECT 
    s.user_id,
    count(DISTINCT (s.day, s.habit_id)) AS total_sends_30d
  FROM public.reminder_sends_daily s
  CROSS JOIN date_range dr
  WHERE s.day >= dr.start_date AND s.day <= dr.end_date
  GROUP BY s.user_id
),
user_actions AS (
  SELECT 
    a.user_id,
    count(*) AS total_actions_30d,
    count(*) FILTER (WHERE a.action = 'done') AS done_count_30d,
    count(*) FILTER (WHERE a.action = 'snooze') AS snooze_count_30d,
    count(*) FILTER (WHERE a.action = 'dismiss') AS dismiss_count_30d
  FROM public.reminder_actions_daily a
  CROSS JOIN date_range dr
  WHERE a.day >= dr.start_date AND a.day <= dr.end_date
  GROUP BY a.user_id
)
SELECT 
  COALESCE(us.user_id, ua.user_id) AS user_id,
  COALESCE(us.total_sends_30d, 0) AS total_sends_30d,
  COALESCE(ua.total_actions_30d, 0) AS total_actions_30d,
  COALESCE(ua.done_count_30d, 0) AS done_count_30d,
  COALESCE(ua.snooze_count_30d, 0) AS snooze_count_30d,
  COALESCE(ua.dismiss_count_30d, 0) AS dismiss_count_30d,
  CASE 
    WHEN COALESCE(ua.total_actions_30d, 0) > 0 
    THEN round((ua.done_count_30d::numeric / ua.total_actions_30d::numeric) * 100, 2)
    ELSE 0 
  END AS done_rate_30d,
  CASE 
    WHEN COALESCE(ua.total_actions_30d, 0) > 0 
    THEN round((ua.snooze_count_30d::numeric / ua.total_actions_30d::numeric) * 100, 2)
    ELSE 0 
  END AS snooze_rate_30d,
  CASE 
    WHEN COALESCE(ua.total_actions_30d, 0) > 0 
    THEN round((ua.dismiss_count_30d::numeric / ua.total_actions_30d::numeric) * 100, 2)
    ELSE 0 
  END AS dismiss_rate_30d,
  now() AS refreshed_at
FROM user_sends us
FULL OUTER JOIN user_actions ua ON us.user_id = ua.user_id;

-- Create unique index for CONCURRENTLY refresh support
CREATE UNIQUE INDEX IF NOT EXISTS idx_reminder_metrics_aggregate_30d_user_id 
  ON public.reminder_metrics_aggregate_30d(user_id);

-- ROW LEVEL SECURITY for views
-- Note: Views inherit RLS from underlying tables, but we add explicit policies for the materialized view

-- Enable RLS on the materialized view
ALTER MATERIALIZED VIEW public.reminder_metrics_aggregate_30d OWNER TO postgres;

-- SECURITY DEFINER function to get analytics for current user only
-- This ensures users can only see their own data
CREATE OR REPLACE FUNCTION public.get_reminder_analytics_summary(
  p_range_days integer DEFAULT 30
)
RETURNS TABLE (
  range_days integer,
  total_sends bigint,
  total_actions bigint,
  done_count bigint,
  snooze_count bigint,
  dismiss_count bigint,
  action_rate_pct numeric,
  done_rate_pct numeric,
  habits_with_prefs bigint,
  habits_enabled_pct numeric
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_start_date date;
BEGIN
  -- Get current user
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;
  
  -- Calculate start date
  v_start_date := current_date - (p_range_days || ' days')::interval;
  
  RETURN QUERY
  WITH sends AS (
    SELECT count(DISTINCT (s.day, s.habit_id)) AS cnt
    FROM reminder_sends_daily s
    WHERE s.user_id = v_user_id 
      AND s.day >= v_start_date 
      AND s.day <= current_date
  ),
  actions AS (
    SELECT 
      sum(a.action_count) AS total,
      sum(a.action_count) FILTER (WHERE a.action = 'done') AS done,
      sum(a.action_count) FILTER (WHERE a.action = 'snooze') AS snooze,
      sum(a.action_count) FILTER (WHERE a.action = 'dismiss') AS dismiss
    FROM reminder_actions_daily a
    WHERE a.user_id = v_user_id 
      AND a.day >= v_start_date 
      AND a.day <= current_date
  ),
  habit_prefs AS (
    SELECT 
      count(*) AS total_prefs,
      count(*) FILTER (WHERE hrp.enabled = true) AS enabled_prefs
    FROM habit_reminder_prefs hrp
    INNER JOIN habits_v2 h ON h.id = hrp.habit_id
    WHERE h.user_id = v_user_id AND h.archived = false
  )
  SELECT 
    p_range_days,
    COALESCE(s.cnt, 0)::bigint,
    COALESCE(a.total, 0)::bigint,
    COALESCE(a.done, 0)::bigint,
    COALESCE(a.snooze, 0)::bigint,
    COALESCE(a.dismiss, 0)::bigint,
    CASE 
      WHEN COALESCE(s.cnt, 0) > 0 
      THEN round((COALESCE(a.total, 0)::numeric / s.cnt::numeric) * 100, 2)
      ELSE 0 
    END,
    CASE 
      WHEN COALESCE(a.total, 0) > 0 
      THEN round((COALESCE(a.done, 0)::numeric / a.total::numeric) * 100, 2)
      ELSE 0 
    END,
    COALESCE(hp.total_prefs, 0)::bigint,
    CASE 
      WHEN COALESCE(hp.total_prefs, 0) > 0 
      THEN round((hp.enabled_prefs::numeric / hp.total_prefs::numeric) * 100, 2)
      ELSE 0 
    END
  FROM sends s
  CROSS JOIN actions a
  CROSS JOIN habit_prefs hp;
END;
$$;

-- Function to get daily analytics for current user
CREATE OR REPLACE FUNCTION public.get_reminder_analytics_daily(
  p_range_days integer DEFAULT 30
)
RETURNS TABLE (
  day date,
  sends bigint,
  done bigint,
  snooze bigint,
  dismiss bigint
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_start_date date;
BEGIN
  -- Get current user
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;
  
  -- Calculate start date
  v_start_date := current_date - (p_range_days || ' days')::interval;
  
  RETURN QUERY
  WITH date_series AS (
    SELECT generate_series(v_start_date, current_date, '1 day'::interval)::date AS day
  ),
  daily_sends AS (
    SELECT s.day, count(DISTINCT s.habit_id) AS sends
    FROM reminder_sends_daily s
    WHERE s.user_id = v_user_id 
      AND s.day >= v_start_date 
      AND s.day <= current_date
    GROUP BY s.day
  ),
  daily_actions AS (
    SELECT 
      a.day,
      sum(a.action_count) FILTER (WHERE a.action = 'done') AS done,
      sum(a.action_count) FILTER (WHERE a.action = 'snooze') AS snooze,
      sum(a.action_count) FILTER (WHERE a.action = 'dismiss') AS dismiss
    FROM reminder_actions_daily a
    WHERE a.user_id = v_user_id 
      AND a.day >= v_start_date 
      AND a.day <= current_date
    GROUP BY a.day
  )
  SELECT 
    ds.day,
    COALESCE(dsn.sends, 0)::bigint,
    COALESCE(da.done, 0)::bigint,
    COALESCE(da.snooze, 0)::bigint,
    COALESCE(da.dismiss, 0)::bigint
  FROM date_series ds
  LEFT JOIN daily_sends dsn ON dsn.day = ds.day
  LEFT JOIN daily_actions da ON da.day = ds.day
  ORDER BY ds.day;
END;
$$;

-- Grant execute permissions to authenticated users
GRANT EXECUTE ON FUNCTION public.get_reminder_analytics_summary(integer) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_reminder_analytics_daily(integer) TO authenticated;

-- Comment on objects for documentation
COMMENT ON VIEW public.reminder_actions_daily IS 'Daily aggregation of reminder action logs (done/snooze/dismiss) per user and habit';
COMMENT ON VIEW public.reminder_sends_daily IS 'Daily reminder sends approximated from habit_reminder_state last_reminder_sent_at';
COMMENT ON VIEW public.reminder_failures_daily IS 'Daily aggregation of reminder delivery failures per user';
COMMENT ON MATERIALIZED VIEW public.reminder_metrics_aggregate_30d IS 'Pre-computed 30-day reminder metrics per user. Refresh with: REFRESH MATERIALIZED VIEW CONCURRENTLY reminder_metrics_aggregate_30d;';
COMMENT ON FUNCTION public.get_reminder_analytics_summary IS 'Get aggregated reminder analytics for current user over specified range (7 or 30 days)';
COMMENT ON FUNCTION public.get_reminder_analytics_daily IS 'Get daily reminder analytics for current user over specified range, zero-filled for missing days';
-- === END MIGRATION: 0009_reminder_analytics_views.sql ===

-- === BEGIN MIGRATION: 0010_timezone_quiet_hours_weekends.sql ===
-- ========================================================
-- MIGRATION 0010: Timezone Quiet Hours & Weekend Skip
-- Purpose: Add quiet hours and weekend skip to user reminder preferences
-- ========================================================

-- Add new columns to user_reminder_prefs table
ALTER TABLE public.user_reminder_prefs
  ADD COLUMN IF NOT EXISTS quiet_hours_start TIME NULL,
  ADD COLUMN IF NOT EXISTS quiet_hours_end TIME NULL,
  ADD COLUMN IF NOT EXISTS skip_weekends BOOLEAN DEFAULT FALSE;

-- Add CHECK constraints for valid time values (00:00:00 to 23:59:59)
-- Quiet hours can have overnight ranges (e.g., 22:00 to 06:00)
-- Both start and end must be provided together, or both null

ALTER TABLE public.user_reminder_prefs
  DROP CONSTRAINT IF EXISTS chk_quiet_hours_both_or_neither;

ALTER TABLE public.user_reminder_prefs
  ADD CONSTRAINT chk_quiet_hours_both_or_neither
  CHECK (
    (quiet_hours_start IS NULL AND quiet_hours_end IS NULL) OR
    (quiet_hours_start IS NOT NULL AND quiet_hours_end IS NOT NULL)
  );

-- Note: We allow overnight ranges (e.g., 22:00 to 06:00) where start > end
-- The application logic handles this case by checking if current time is
-- either >= start OR <= end when start > end

-- Add comment explaining the quiet hours logic
COMMENT ON COLUMN public.user_reminder_prefs.quiet_hours_start IS 
  'Start time for quiet hours (no reminders). Supports overnight ranges where start > end (e.g., 22:00-06:00).';

COMMENT ON COLUMN public.user_reminder_prefs.quiet_hours_end IS 
  'End time for quiet hours (no reminders). Supports overnight ranges where start > end (e.g., 22:00-06:00).';

COMMENT ON COLUMN public.user_reminder_prefs.skip_weekends IS 
  'When true, reminders are not sent on Saturday (6) or Sunday (0).';

-- RLS policies already exist for user_reminder_prefs from migration 0007
-- The existing "own_reminder_prefs" policy covers all columns:
--   FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id)
-- No additional RLS changes needed.
-- === END MIGRATION: 0010_timezone_quiet_hours_weekends.sql ===

-- === BEGIN MIGRATION: 0011_merge_legacy_habits_into_v2.sql ===
-- ========================================================
-- HABITS MODULE - MERGE LEGACY HABITS INTO V2
-- Migration 0011: Migrate data from legacy habits tables to v2
-- 
-- Purpose: Consolidate the two habit systems into a single,
-- React-based Habits V2 implementation without loss of functionality,
-- preserving historical data and Today checklist UX in the PWA.
--
-- HARDENED: This migration is resilient to missing legacy tables.
-- It will run successfully whether or not legacy tables exist.
-- ========================================================

-- Step 1: Create migration map table to track old→new habit ID mappings
-- This allows us to maintain references and rollback if needed
CREATE TABLE IF NOT EXISTS public.habit_migration_map (
    old_habit_id uuid NOT NULL,
    new_habit_v2_id uuid NOT NULL,
    migrated_at timestamptz NOT NULL DEFAULT now(),
    migration_notes text,
    PRIMARY KEY (old_habit_id)
);

-- Index for reverse lookup (v2 ID → legacy ID)
CREATE INDEX IF NOT EXISTS idx_habit_migration_map_new_id 
    ON public.habit_migration_map(new_habit_v2_id);

-- RLS for migration map (admin-only access typically)
ALTER TABLE public.habit_migration_map ENABLE ROW LEVEL SECURITY;

-- Conditionally create the RLS policy only if public.habits table exists
-- If legacy habits table is absent, create a fallback policy
DO $$
BEGIN
    -- Drop any existing policy first
    DROP POLICY IF EXISTS "users_view_own_migrations" ON public.habit_migration_map;
    
    -- Check if public.habits table exists
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habits'
    ) THEN
        -- Legacy table exists: create policy that references it
        EXECUTE '
            CREATE POLICY "users_view_own_migrations" ON public.habit_migration_map
                FOR SELECT USING (
                    EXISTS (
                        SELECT 1 FROM public.habits h
                        JOIN public.goals g ON h.goal_id = g.id
                        WHERE h.id = habit_migration_map.old_habit_id 
                        AND g.user_id = auth.uid()
                    )
                )
        ';
        RAISE NOTICE 'Created migration_map policy using legacy habits table.';
    ELSE
        -- Legacy table does not exist: create fallback policy via habits_v2
        EXECUTE '
            CREATE POLICY "users_view_own_migrations" ON public.habit_migration_map
                FOR SELECT USING (
                    EXISTS (
                        SELECT 1 FROM public.habits_v2 h
                        WHERE h.id = habit_migration_map.new_habit_v2_id 
                        AND h.user_id = auth.uid()
                    )
                )
        ';
        RAISE NOTICE 'Legacy habits table absent. Created fallback migration_map policy using habits_v2.';
    END IF;
END $$;

-- ========================================================
-- Step 2: Migrate habits from public.habits → habits_v2
-- Field mappings:
--   habits.name → habits_v2.title
--   habits.goal_id → habits_v2.goal_id  
--   habits.frequency → used to derive schedule mode
--   habits.schedule → habits_v2.schedule (transformed)
--   type defaults to 'boolean' for legacy habits
--
-- GUARDED: Only runs if public.habits table exists
-- ========================================================

-- Function to convert legacy schedule JSON to v2 format
CREATE OR REPLACE FUNCTION migrate_legacy_schedule(
    legacy_frequency text,
    legacy_schedule jsonb
) RETURNS jsonb AS $$
DECLARE
    result jsonb;
    schedule_type text;
    days_array int[];
BEGIN
    -- Default to daily if no schedule specified
    IF legacy_schedule IS NULL OR legacy_schedule = 'null'::jsonb THEN
        RETURN '{"mode": "daily"}'::jsonb;
    END IF;

    -- Check for type field in schedule
    schedule_type := legacy_schedule->>'type';
    
    IF schedule_type = 'daily' THEN
        RETURN '{"mode": "daily"}'::jsonb;
    END IF;
    
    IF schedule_type = 'weekly' AND legacy_schedule->'days' IS NOT NULL THEN
        -- Convert day names to day indices
        SELECT ARRAY(
            SELECT CASE lower(d::text)
                WHEN '"sunday"' THEN 0
                WHEN '"sun"' THEN 0
                WHEN '"monday"' THEN 1
                WHEN '"mon"' THEN 1
                WHEN '"tuesday"' THEN 2
                WHEN '"tue"' THEN 2
                WHEN '"wednesday"' THEN 3
                WHEN '"wed"' THEN 3
                WHEN '"thursday"' THEN 4
                WHEN '"thu"' THEN 4
                WHEN '"friday"' THEN 5
                WHEN '"fri"' THEN 5
                WHEN '"saturday"' THEN 6
                WHEN '"sat"' THEN 6
                ELSE NULL
            END
            FROM jsonb_array_elements(legacy_schedule->'days') AS d
            WHERE d IS NOT NULL
        ) INTO days_array;
        
        IF array_length(days_array, 1) > 0 THEN
            RETURN jsonb_build_object('mode', 'specific_days', 'days', days_array);
        END IF;
    END IF;
    
    -- Check if schedule is already an array of days
    IF jsonb_typeof(legacy_schedule) = 'array' THEN
        SELECT ARRAY(
            SELECT CASE lower(d::text)
                WHEN '"sunday"' THEN 0
                WHEN '"sun"' THEN 0
                WHEN '"monday"' THEN 1
                WHEN '"mon"' THEN 1
                WHEN '"tuesday"' THEN 2
                WHEN '"tue"' THEN 2
                WHEN '"wednesday"' THEN 3
                WHEN '"wed"' THEN 3
                WHEN '"thursday"' THEN 4
                WHEN '"thu"' THEN 4
                WHEN '"friday"' THEN 5
                WHEN '"fri"' THEN 5
                WHEN '"saturday"' THEN 6
                WHEN '"sat"' THEN 6
                ELSE NULL
            END
            FROM jsonb_array_elements(legacy_schedule) AS d
        ) INTO days_array;
        
        IF array_length(days_array, 1) > 0 THEN
            RETURN jsonb_build_object('mode', 'specific_days', 'days', days_array);
        END IF;
    END IF;
    
    -- Fallback: parse frequency string
    IF legacy_frequency IS NOT NULL THEN
        IF lower(legacy_frequency) LIKE '%daily%' THEN
            RETURN '{"mode": "daily"}'::jsonb;
        ELSIF lower(legacy_frequency) LIKE '%weekly%' THEN
            -- Default to daily for generic weekly
            RETURN '{"mode": "daily"}'::jsonb;
        END IF;
    END IF;
    
    -- Default fallback
    RETURN '{"mode": "daily"}'::jsonb;
END;
$$ LANGUAGE plpgsql;

-- Perform the migration (only if legacy habits table exists)
DO $$
DECLARE
    legacy_habit RECORD;
    new_habit_id uuid;
    user_id_for_habit uuid;
    v2_schedule jsonb;
    habits_exist boolean;
BEGIN
    -- Check if public.habits table exists
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habits'
    ) INTO habits_exist;
    
    IF NOT habits_exist THEN
        RAISE NOTICE 'SKIP: Legacy public.habits table does not exist. No habits migration needed.';
        RETURN;
    END IF;
    
    -- Iterate through each legacy habit that hasn't been migrated
    FOR legacy_habit IN 
        SELECT h.id, h.goal_id, h.name, h.frequency, h.schedule
        FROM public.habits h
        LEFT JOIN public.habit_migration_map m ON h.id = m.old_habit_id
        WHERE m.old_habit_id IS NULL
    LOOP
        -- Get the user_id from the associated goal
        SELECT g.user_id INTO user_id_for_habit
        FROM public.goals g
        WHERE g.id = legacy_habit.goal_id;
        
        -- Skip if no user found (orphaned habit)
        IF user_id_for_habit IS NULL THEN
            CONTINUE;
        END IF;
        
        -- Convert schedule to v2 format
        v2_schedule := migrate_legacy_schedule(
            legacy_habit.frequency,
            legacy_habit.schedule::jsonb
        );
        
        -- Insert into habits_v2 (loop already filters unmigrated habits via LEFT JOIN)
        INSERT INTO public.habits_v2 (
            user_id,
            title,
            emoji,
            type,
            schedule,
            goal_id,
            archived,
            created_at
        ) VALUES (
            user_id_for_habit,
            legacy_habit.name,
            NULL, -- No emoji in legacy
            'boolean', -- Default type for legacy habits
            v2_schedule,
            legacy_habit.goal_id,
            false,
            now()
        )
        RETURNING id INTO new_habit_id;
        
        -- Record the mapping with ON CONFLICT for idempotency
        INSERT INTO public.habit_migration_map (old_habit_id, new_habit_v2_id, migration_notes)
        VALUES (legacy_habit.id, new_habit_id, 'Automated migration from legacy habits')
        ON CONFLICT (old_habit_id) DO NOTHING;
        
    END LOOP;
    
    RAISE NOTICE 'Legacy habits migration completed successfully.';
END $$;

-- ========================================================
-- Step 3: Migrate habit_logs from public.habit_logs → habit_logs_v2
-- Field mappings:
--   habit_logs.habit_id → lookup via migration_map → habit_logs_v2.habit_id
--   habit_logs.date → habit_logs_v2.date
--   habit_logs.completed → habit_logs_v2.done
--   value defaults to NULL (boolean logs)
--
-- GUARDED: Only runs if public.habit_logs table exists
-- ========================================================

DO $$
DECLARE
    legacy_log RECORD;
    new_habit_id uuid;
    user_id_for_habit uuid;
    habit_logs_exist boolean;
BEGIN
    -- Check if public.habit_logs table exists
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habit_logs'
    ) INTO habit_logs_exist;
    
    IF NOT habit_logs_exist THEN
        RAISE NOTICE 'SKIP: Legacy public.habit_logs table does not exist. No logs migration needed.';
        RETURN;
    END IF;
    
    -- Iterate through each legacy log for migrated habits
    FOR legacy_log IN 
        SELECT l.id, l.habit_id, l.date, l.completed, m.new_habit_v2_id
        FROM public.habit_logs l
        JOIN public.habit_migration_map m ON l.habit_id = m.old_habit_id
        LEFT JOIN public.habit_logs_v2 v2 ON 
            v2.habit_id = m.new_habit_v2_id AND 
            v2.date = l.date
        WHERE v2.id IS NULL -- Only migrate if not already present
    LOOP
        -- Get user_id from the v2 habit
        SELECT user_id INTO user_id_for_habit
        FROM public.habits_v2
        WHERE id = legacy_log.new_habit_v2_id;
        
        IF user_id_for_habit IS NOT NULL THEN
            -- Insert into habit_logs_v2 with ON CONFLICT handling
            INSERT INTO public.habit_logs_v2 (
                habit_id,
                user_id,
                date,
                done,
                value,
                note
            ) VALUES (
                legacy_log.new_habit_v2_id,
                user_id_for_habit,
                legacy_log.date,
                legacy_log.completed,
                NULL, -- No value in legacy logs
                'Migrated from legacy habit_logs'
            )
            ON CONFLICT DO NOTHING;
        END IF;
    END LOOP;
    
    RAISE NOTICE 'Legacy habit_logs migration completed successfully.';
END $$;

-- ========================================================
-- Step 4: Translate habit_alerts → habit_reminder_prefs
-- Field mappings:
--   habit_alerts.habit_id → lookup via migration_map → habit_reminder_prefs.habit_id
--   habit_alerts.alert_time → habit_reminder_prefs.preferred_time
--   habit_alerts.enabled → habit_reminder_prefs.enabled
--   habit_alerts.days_of_week → embedded in v2 schedule (best-effort)
--
-- GUARDED: Only runs if public.habit_alerts table exists
-- ========================================================

DO $$
DECLARE
    legacy_alert RECORD;
    new_habit_id uuid;
    habit_alerts_exist boolean;
BEGIN
    -- Check if public.habit_alerts table exists
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habit_alerts'
    ) INTO habit_alerts_exist;
    
    IF NOT habit_alerts_exist THEN
        RAISE NOTICE 'SKIP: Legacy public.habit_alerts table does not exist. No alerts migration needed.';
        RETURN;
    END IF;
    
    -- Iterate through each legacy alert for migrated habits
    FOR legacy_alert IN 
        SELECT a.id, a.habit_id, a.alert_time, a.enabled, a.days_of_week, m.new_habit_v2_id
        FROM public.habit_alerts a
        JOIN public.habit_migration_map m ON a.habit_id = m.old_habit_id
        LEFT JOIN public.habit_reminder_prefs p ON p.habit_id = m.new_habit_v2_id
        WHERE p.habit_id IS NULL -- Only migrate if not already present
    LOOP
        -- Insert into habit_reminder_prefs
        INSERT INTO public.habit_reminder_prefs (
            habit_id,
            enabled,
            preferred_time,
            created_at,
            updated_at
        ) VALUES (
            legacy_alert.new_habit_v2_id,
            legacy_alert.enabled,
            legacy_alert.alert_time,
            now(),
            now()
        )
        ON CONFLICT (habit_id) DO UPDATE SET
            enabled = EXCLUDED.enabled,
            preferred_time = EXCLUDED.preferred_time,
            updated_at = now();
    END LOOP;
    
    RAISE NOTICE 'Legacy habit_alerts migration completed successfully.';
END $$;

-- ========================================================
-- Step 5: Create read-only lock mechanism for legacy tables
-- Controlled via a feature flag row in a config table
--
-- GUARDED: Triggers are only created if legacy tables exist
-- ========================================================

-- Create config table for feature flags if not exists
CREATE TABLE IF NOT EXISTS public.app_config (
    key text PRIMARY KEY,
    value jsonb NOT NULL DEFAULT '{}'::jsonb,
    description text,
    updated_at timestamptz DEFAULT now()
);

-- Insert the legacy tables read-only flag (defaults to false/disabled)
INSERT INTO public.app_config (key, value, description)
VALUES (
    'legacy_habits_readonly',
    '{"enabled": false}'::jsonb,
    'When enabled, blocks INSERT/UPDATE/DELETE on legacy habits, habit_logs, and habit_alerts tables'
)
ON CONFLICT (key) DO NOTHING;

-- Function to check if legacy tables are read-only
CREATE OR REPLACE FUNCTION check_legacy_habits_readonly()
RETURNS TRIGGER AS $$
DECLARE
    is_readonly boolean;
BEGIN
    SELECT (value->>'enabled')::boolean INTO is_readonly
    FROM public.app_config
    WHERE key = 'legacy_habits_readonly';
    
    IF is_readonly = true THEN
        RAISE EXCEPTION 'Legacy habits tables are in read-only mode. Please use habits_v2 instead.';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add triggers to enforce read-only mode on legacy tables
-- GUARDED: Only create triggers if the corresponding tables exist

DO $$
BEGIN
    -- Guard trigger creation for public.habits
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habits'
    ) THEN
        DROP TRIGGER IF EXISTS enforce_readonly_habits ON public.habits;
        CREATE TRIGGER enforce_readonly_habits
            BEFORE INSERT OR UPDATE OR DELETE ON public.habits
            FOR EACH ROW
            EXECUTE FUNCTION check_legacy_habits_readonly();
        RAISE NOTICE 'Created read-only trigger on public.habits';
    ELSE
        RAISE NOTICE 'SKIP: public.habits does not exist. No trigger created.';
    END IF;
    
    -- Guard trigger creation for public.habit_logs
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habit_logs'
    ) THEN
        DROP TRIGGER IF EXISTS enforce_readonly_habit_logs ON public.habit_logs;
        CREATE TRIGGER enforce_readonly_habit_logs
            BEFORE INSERT OR UPDATE OR DELETE ON public.habit_logs
            FOR EACH ROW
            EXECUTE FUNCTION check_legacy_habits_readonly();
        RAISE NOTICE 'Created read-only trigger on public.habit_logs';
    ELSE
        RAISE NOTICE 'SKIP: public.habit_logs does not exist. No trigger created.';
    END IF;
    
    -- Guard trigger creation for public.habit_alerts
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habit_alerts'
    ) THEN
        DROP TRIGGER IF EXISTS enforce_readonly_habit_alerts ON public.habit_alerts;
        CREATE TRIGGER enforce_readonly_habit_alerts
            BEFORE INSERT OR UPDATE OR DELETE ON public.habit_alerts
            FOR EACH ROW
            EXECUTE FUNCTION check_legacy_habits_readonly();
        RAISE NOTICE 'Created read-only trigger on public.habit_alerts';
    ELSE
        RAISE NOTICE 'SKIP: public.habit_alerts does not exist. No trigger created.';
    END IF;
END $$;

-- ========================================================
-- Verification queries (as comments for manual verification)
-- ========================================================

-- Verify migration counts:
-- SELECT 
--     (SELECT COUNT(*) FROM public.habits) AS legacy_habits_count,
--     (SELECT COUNT(*) FROM public.habit_migration_map) AS migrated_count,
--     (SELECT COUNT(*) FROM public.habits_v2 WHERE goal_id IS NOT NULL) AS v2_with_goal_count;

-- Verify log migration:
-- SELECT
--     (SELECT COUNT(*) FROM public.habit_logs) AS legacy_logs_count,
--     (SELECT COUNT(*) FROM public.habit_logs_v2 WHERE note LIKE '%Migrated%') AS migrated_logs_count;

-- Verify alert migration:
-- SELECT
--     (SELECT COUNT(*) FROM public.habit_alerts) AS legacy_alerts_count,
--     (SELECT COUNT(*) FROM public.habit_reminder_prefs) AS v2_prefs_count;

-- Enable read-only mode (run manually after verification):
-- UPDATE public.app_config 
-- SET value = '{"enabled": true}'::jsonb, updated_at = now()
-- WHERE key = 'legacy_habits_readonly';

-- Disable read-only mode (for rollback):
-- UPDATE public.app_config 
-- SET value = '{"enabled": false}'::jsonb, updated_at = now()
-- WHERE key = 'legacy_habits_readonly';

COMMENT ON TABLE public.habit_migration_map IS 
'Tracks mapping of legacy habit IDs to v2 habit IDs for migration and rollback support.';

COMMENT ON TABLE public.app_config IS 
'Application configuration flags including legacy_habits_readonly for migration control.';
-- === END MIGRATION: 0011_merge_legacy_habits_into_v2.sql ===

-- === BEGIN MIGRATION: 0012_archive_and_drop_legacy_habits.sql ===
-- ========================================================
-- HABITS MODULE - ARCHIVE AND DROP LEGACY TABLES
-- Migration 0012: Post-merge cleanup
-- 
-- WARNING: This migration should ONLY be run after:
-- 1. Migration 0011 has been applied and verified
-- 2. Read-only mode has been enabled for 3-7 days
-- 3. All legacy habits data has been confirmed migrated
-- 4. The application has been updated to use habitsV2 exclusively
--
-- HARDENED: This migration is resilient to missing legacy tables 
-- and does NOT depend on app_config. All operations are guarded.
--
-- This migration:
-- 1. Archives legacy tables (creates backup copies) - IF THEY EXIST
-- 2. Drops the legacy tables, indexes, triggers, and RLS policies
-- 3. Cleans up any remaining references
-- ========================================================

-- Step 0: Safety check and information notice
-- No longer requires app_config - just logs status
DO $$
DECLARE
    app_config_exists boolean;
    readonly_enabled boolean;
BEGIN
    -- Check if app_config table exists
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'app_config'
    ) INTO app_config_exists;
    
    IF app_config_exists THEN
        SELECT (value->>'enabled')::boolean INTO readonly_enabled
        FROM public.app_config
        WHERE key = 'legacy_habits_readonly';
        
        IF readonly_enabled IS NULL OR readonly_enabled = false THEN
            RAISE NOTICE 'INFO: legacy_habits_readonly was not enabled in app_config.';
            RAISE NOTICE 'Proceeding with cleanup since this migration is designed to be resilient.';
        ELSE
            RAISE NOTICE 'INFO: legacy_habits_readonly was enabled. Proceeding with cleanup.';
        END IF;
    ELSE
        RAISE NOTICE 'INFO: app_config table does not exist. Proceeding with cleanup.';
    END IF;
END $$;

-- ========================================================
-- Step 1: Archive legacy tables (IF THEY EXIST)
-- Creates copies with _archived suffix for backup
-- ========================================================

-- Archive habits table (guarded)
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habits'
    ) THEN
        -- Only create archive if it doesn't exist yet
        IF NOT EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' AND table_name = 'habits_archived'
        ) THEN
            CREATE TABLE public.habits_archived AS 
            SELECT *, now() AS archived_at
            FROM public.habits;
            RAISE NOTICE 'Created archive: public.habits_archived';
        ELSE
            RAISE NOTICE 'Archive already exists: public.habits_archived - skipping.';
        END IF;
    ELSE
        RAISE NOTICE 'SKIP: public.habits does not exist. No archive needed.';
    END IF;
END $$;

-- Archive habit_logs table (guarded)
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habit_logs'
    ) THEN
        IF NOT EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' AND table_name = 'habit_logs_archived'
        ) THEN
            CREATE TABLE public.habit_logs_archived AS
            SELECT *, now() AS archived_at
            FROM public.habit_logs;
            RAISE NOTICE 'Created archive: public.habit_logs_archived';
        ELSE
            RAISE NOTICE 'Archive already exists: public.habit_logs_archived - skipping.';
        END IF;
    ELSE
        RAISE NOTICE 'SKIP: public.habit_logs does not exist. No archive needed.';
    END IF;
END $$;

-- Archive habit_alerts table (guarded)
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habit_alerts'
    ) THEN
        IF NOT EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' AND table_name = 'habit_alerts_archived'
        ) THEN
            CREATE TABLE public.habit_alerts_archived AS
            SELECT *, now() AS archived_at
            FROM public.habit_alerts;
            RAISE NOTICE 'Created archive: public.habit_alerts_archived';
        ELSE
            RAISE NOTICE 'Archive already exists: public.habit_alerts_archived - skipping.';
        END IF;
    ELSE
        RAISE NOTICE 'SKIP: public.habit_alerts does not exist. No archive needed.';
    END IF;
END $$;

-- Add comments to archived tables (if they exist)
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habits_archived'
    ) THEN
        COMMENT ON TABLE public.habits_archived IS 
        'Archived copy of legacy habits table. Created during v2 migration cleanup.';
    END IF;
    
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habit_logs_archived'
    ) THEN
        COMMENT ON TABLE public.habit_logs_archived IS 
        'Archived copy of legacy habit_logs table. Created during v2 migration cleanup.';
    END IF;
    
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habit_alerts_archived'
    ) THEN
        COMMENT ON TABLE public.habit_alerts_archived IS 
        'Archived copy of legacy habit_alerts table. Created during v2 migration cleanup.';
    END IF;
END $$;

-- ========================================================
-- Step 2: Drop triggers from legacy tables (guarded)
-- ========================================================

DO $$
BEGIN
    -- Drop read-only enforcement triggers (only if tables exist)
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habits'
    ) THEN
        DROP TRIGGER IF EXISTS enforce_readonly_habits ON public.habits;
        RAISE NOTICE 'Dropped trigger enforce_readonly_habits from public.habits';
    END IF;
    
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habit_logs'
    ) THEN
        DROP TRIGGER IF EXISTS enforce_readonly_habit_logs ON public.habit_logs;
        RAISE NOTICE 'Dropped trigger enforce_readonly_habit_logs from public.habit_logs';
    END IF;
    
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habit_alerts'
    ) THEN
        DROP TRIGGER IF EXISTS enforce_readonly_habit_alerts ON public.habit_alerts;
        RAISE NOTICE 'Dropped trigger enforce_readonly_habit_alerts from public.habit_alerts';
    END IF;
END $$;

-- ========================================================
-- Step 3: Drop RLS policies from legacy tables (guarded)
-- ========================================================

-- Drop any RLS policies on habits (if table exists)
DO $$
DECLARE
    policy_record RECORD;
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habits'
    ) THEN
        FOR policy_record IN 
            SELECT policyname 
            FROM pg_policies 
            WHERE tablename = 'habits' AND schemaname = 'public'
        LOOP
            EXECUTE format('DROP POLICY IF EXISTS %I ON public.habits', policy_record.policyname);
            RAISE NOTICE 'Dropped policy % from public.habits', policy_record.policyname;
        END LOOP;
    END IF;
END $$;

-- Drop any RLS policies on habit_logs (if table exists)
DO $$
DECLARE
    policy_record RECORD;
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habit_logs'
    ) THEN
        FOR policy_record IN 
            SELECT policyname 
            FROM pg_policies 
            WHERE tablename = 'habit_logs' AND schemaname = 'public'
        LOOP
            EXECUTE format('DROP POLICY IF EXISTS %I ON public.habit_logs', policy_record.policyname);
            RAISE NOTICE 'Dropped policy % from public.habit_logs', policy_record.policyname;
        END LOOP;
    END IF;
END $$;

-- Drop any RLS policies on habit_alerts (if table exists)
DO $$
DECLARE
    policy_record RECORD;
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habit_alerts'
    ) THEN
        FOR policy_record IN 
            SELECT policyname 
            FROM pg_policies 
            WHERE tablename = 'habit_alerts' AND schemaname = 'public'
        LOOP
            EXECUTE format('DROP POLICY IF EXISTS %I ON public.habit_alerts', policy_record.policyname);
            RAISE NOTICE 'Dropped policy % from public.habit_alerts', policy_record.policyname;
        END LOOP;
    END IF;
END $$;

-- ========================================================
-- Step 4: Drop indexes from legacy tables
-- Using IF EXISTS for all - safe even if they don't exist
-- ========================================================

-- Common index patterns to drop
DROP INDEX IF EXISTS public.idx_habits_goal_id;
DROP INDEX IF EXISTS public.idx_habits_name;
DROP INDEX IF EXISTS public.habits_goal_id_idx;

DROP INDEX IF EXISTS public.idx_habit_logs_habit_id;
DROP INDEX IF EXISTS public.idx_habit_logs_date;
DROP INDEX IF EXISTS public.idx_habit_logs_habit_date;
DROP INDEX IF EXISTS public.habit_logs_habit_id_idx;
DROP INDEX IF EXISTS public.habit_logs_date_idx;

DROP INDEX IF EXISTS public.idx_habit_alerts_habit_id;
DROP INDEX IF EXISTS public.idx_habit_alerts_alert_time;
DROP INDEX IF EXISTS public.habit_alerts_habit_id_idx;

-- ========================================================
-- Step 5: Drop legacy tables
-- Using IF EXISTS CASCADE - safe even if they don't exist
-- ========================================================

-- Drop habit_alerts first (no foreign key dependencies)
DROP TABLE IF EXISTS public.habit_alerts CASCADE;

-- Drop habit_logs (depends on habits)
DROP TABLE IF EXISTS public.habit_logs CASCADE;

-- Drop habits (has foreign key to goals)
DROP TABLE IF EXISTS public.habits CASCADE;

-- Log completion of table drops
DO $$
BEGIN
    RAISE NOTICE 'Legacy tables dropped (if they existed).';
END $$;

-- ========================================================
-- Step 6: Clean up helper functions
-- ========================================================

-- Drop the read-only check function (no longer needed)
DROP FUNCTION IF EXISTS public.check_legacy_habits_readonly();

-- Drop the legacy schedule migration function (no longer needed)
DROP FUNCTION IF EXISTS public.migrate_legacy_schedule(text, jsonb);

-- ========================================================
-- Step 7: Update app_config to mark cleanup complete (if exists)
-- This step is optional - migration works without app_config
-- ========================================================

DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'app_config'
    ) THEN
        -- Update the legacy_habits_readonly flag
        UPDATE public.app_config 
        SET value = jsonb_build_object(
            'enabled', false,
            'cleanup_completed_at', now()::text,
            'cleanup_migration', '0012_archive_and_drop_legacy_habits.sql'
        ),
            updated_at = now()
        WHERE key = 'legacy_habits_readonly';
        
        -- Add a new config entry to track cleanup status
        INSERT INTO public.app_config (key, value, description)
        VALUES (
            'legacy_habits_cleanup_status',
            jsonb_build_object(
                'status', 'completed',
                'completed_at', now()::text,
                'archived_tables', ARRAY['habits_archived', 'habit_logs_archived', 'habit_alerts_archived']
            ),
            'Tracks the status of legacy habits cleanup migration'
        )
        ON CONFLICT (key) DO UPDATE SET
            value = EXCLUDED.value,
            updated_at = now();
        
        RAISE NOTICE 'Updated app_config with cleanup status.';
    ELSE
        RAISE NOTICE 'SKIP: app_config table does not exist. Cleanup status not recorded.';
    END IF;
END $$;

-- ========================================================
-- Verification queries (run after migration)
-- ========================================================

/*
-- Verify legacy tables are dropped:
SELECT table_name 
FROM information_schema.tables 
WHERE table_schema = 'public' 
  AND table_name IN ('habits', 'habit_logs', 'habit_alerts');
-- Expected: Empty result set

-- Verify archived tables exist (if legacy tables existed):
SELECT table_name 
FROM information_schema.tables 
WHERE table_schema = 'public' 
  AND table_name IN ('habits_archived', 'habit_logs_archived', 'habit_alerts_archived');
-- Expected: Up to 3 rows (only for tables that existed)

-- Verify migration map exists and has data:
SELECT COUNT(*) AS migration_count FROM public.habit_migration_map;
-- Expected: Count > 0 if there were legacy habits

-- Verify v2 tables are intact:
SELECT 
    (SELECT COUNT(*) FROM public.habits_v2) AS v2_habits,
    (SELECT COUNT(*) FROM public.habit_logs_v2) AS v2_logs,
    (SELECT COUNT(*) FROM public.habit_reminder_prefs) AS v2_reminder_prefs;

-- Verify no remaining RLS policies on dropped tables:
SELECT schemaname, tablename, policyname
FROM pg_policies
WHERE tablename IN ('habits', 'habit_logs', 'habit_alerts')
  AND schemaname = 'public';
-- Expected: Empty result set

-- Check cleanup status (if app_config exists):
SELECT key, value, updated_at 
FROM public.app_config 
WHERE key IN ('legacy_habits_readonly', 'legacy_habits_cleanup_status');
*/

-- ========================================================
-- Rollback instructions (if needed)
-- ========================================================

/*
ROLLBACK STEPS (execute manually if rollback is required):

1. Restore habits table from archive (if archive exists):
CREATE TABLE public.habits AS 
SELECT id, goal_id, name, frequency, schedule 
FROM public.habits_archived;

2. Restore habit_logs table from archive (if archive exists):
CREATE TABLE public.habit_logs AS 
SELECT id, habit_id, date, completed 
FROM public.habit_logs_archived;

3. Restore habit_alerts table from archive (if archive exists):
CREATE TABLE public.habit_alerts AS 
SELECT id, habit_id, alert_time, days_of_week, enabled, created_at, updated_at 
FROM public.habit_alerts_archived;

4. Add necessary constraints and indexes back manually.

5. Update app_config (if it exists):
UPDATE public.app_config 
SET value = '{"status": "rolled_back"}'::jsonb
WHERE key = 'legacy_habits_cleanup_status';

NOTE: If rollback is needed, consider whether to keep the migrated v2 data
or revert to using only legacy tables.
*/

-- Add final comments to archived tables (safe to call even if tables don't exist)
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habits_archived'
    ) THEN
        COMMENT ON TABLE public.habits_archived IS 
        'Archived legacy habits table. Safe to drop after confirming v2 migration success (recommend 30+ days).';
    END IF;
    
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habit_logs_archived'
    ) THEN
        COMMENT ON TABLE public.habit_logs_archived IS 
        'Archived legacy habit_logs table. Safe to drop after confirming v2 migration success (recommend 30+ days).';
    END IF;
    
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habit_alerts_archived'
    ) THEN
        COMMENT ON TABLE public.habit_alerts_archived IS 
        'Archived legacy habit_alerts table. Safe to drop after confirming v2 migration success (recommend 30+ days).';
    END IF;
    
    RAISE NOTICE 'Migration 0012 completed successfully.';
END $$;
-- === END MIGRATION: 0012_archive_and_drop_legacy_habits.sql ===

-- === BEGIN MIGRATION: 0101_vision_core.sql ===
-- Ensure tz on profiles
do $$ begin
  alter table public.profiles add column if not exists tz text default 'UTC';
exception when others then null; end $$;

do $$
begin
  begin
    create type vb_board_type as enum ('vision','focus');
  exception when duplicate_object then
    null;
  end;
end$$;

do $$
begin
  begin
    create type vb_card_size as enum ('S','M','L','XL');
  exception when duplicate_object then
    null;
  end;
end$$;

create table if not exists public.vb_boards (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  title text not null,
  board_type vb_board_type not null default 'vision',
  theme jsonb default '{}'::jsonb,
  cover_card_id uuid,
  archived boolean default false,
  created_at timestamptz default now()
);

create table if not exists public.vb_sections (
  id uuid primary key default gen_random_uuid(),
  board_id uuid not null references public.vb_boards(id) on delete cascade,
  title text not null,
  sort_index int default 0
);

create table if not exists public.vb_cards (
  id uuid primary key default gen_random_uuid(),
  board_id uuid not null references public.vb_boards(id) on delete cascade,
  section_id uuid references public.vb_sections(id) on delete set null,
  user_id uuid not null references auth.users(id) on delete cascade,
  kind text not null default 'image',       -- 'image' | 'text'
  title text,
  affirm text,
  color text,
  tags text[] default '{}',
  size vb_card_size default 'M',
  favorite boolean default false,
  visible_in_share boolean default true,
  link_type text,                           -- 'habit' | 'goal' | null
  link_id uuid,
  img_path text,
  img_w int, img_h int,
  sort_index int default 0,
  created_at timestamptz default now()
);

create or replace view public.vb_board_stats as
  select b.id board_id,
         count(c.*) as card_count,
         coalesce(sum(case when c.favorite then 1 else 0 end),0) as favorite_count
  from vb_boards b
  left join vb_cards c on c.board_id=b.id
  group by b.id;

-- RLS
alter table public.vb_boards enable row level security;
alter table public.vb_sections enable row level security;
alter table public.vb_cards enable row level security;

do $$
begin
  if exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'vb_boards'
      and policyname = 'own boards'
  ) then
    execute 'drop policy "own boards" on public.vb_boards';
  end if;
end $$;

create policy "own boards" on public.vb_boards
  for all using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

do $$
begin
  if exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'vb_sections'
      and policyname = 'sections of own boards'
  ) then
    execute 'drop policy "sections of own boards" on public.vb_sections';
  end if;
end $$;

do $$
begin
  if exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'vb_cards'
      and policyname = 'own cards'
  ) then
    execute 'drop policy "own cards" on public.vb_cards';
  end if;
end $$;

do $$
begin
  if exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'vb_cards'
      and policyname = 'own cards'
  ) then
    execute 'drop policy "own cards" on public.vb_cards';
  end if;
end $$;

create policy "own cards" on public.vb_cards
  for all using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

do $$ begin perform gen_random_uuid(); exception when undefined_function then
  create extension if not exists pgcrypto; end $$;
-- === END MIGRATION: 0101_vision_core.sql ===

-- === BEGIN MIGRATION: 0102_sharing_push.sql ===
create table if not exists public.vb_shares (
  id uuid primary key default gen_random_uuid(),
  board_id uuid not null references public.vb_boards(id) on delete cascade,
  owner_id uuid not null references auth.users(id) on delete cascade,
  slug text unique not null,
  is_active boolean default true,
  created_at timestamptz default now()
);
alter table public.vb_shares enable row level security;
do $$
begin
  if exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'vb_shares'
      and policyname = 'owner manage share'
  ) then
    execute 'drop policy "owner manage share" on public.vb_shares';
  end if;
end$$ language plpgsql;
create policy "owner manage share" on public.vb_shares
  for all using (auth.uid() = owner_id) with check (auth.uid() = owner_id);

create table if not exists public.push_subscriptions (
  user_id uuid not null references auth.users(id) on delete cascade,
  endpoint text primary key,
  p256dh text not null,
  auth text not null,
  created_at timestamptz default now()
);
alter table public.push_subscriptions enable row level security;
do $$
begin
  if exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'push_subscriptions'
      and policyname = 'own push'
  ) then
    execute 'drop policy "own push" on public.push_subscriptions';
  end if;
end$$ language plpgsql;
create policy "own push" on public.push_subscriptions
  for all using (auth.uid() = user_id) with check (auth.uid() = user_id);
-- === END MIGRATION: 0102_sharing_push.sql ===

-- === BEGIN MIGRATION: 0103_gratitude_mood.sql ===
create table if not exists public.vb_checkins (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  board_id uuid references public.vb_boards(id) on delete set null,
  the_date date not null default current_date,
  mood int check (mood between 1 and 5),
  gratitude text,
  created_at timestamptz default now()
);

create unique index if not exists vb_checkins_user_date_board_idx
  on public.vb_checkins (user_id, the_date, coalesce(board_id, '00000000-0000-0000-0000-000000000000'::uuid));
alter table public.vb_checkins enable row level security;
drop policy if exists "own checkins" on public.vb_checkins;
create policy "own checkins" on public.vb_checkins
  for all using (auth.uid() = user_id) with check (auth.uid() = user_id);
-- === END MIGRATION: 0103_gratitude_mood.sql ===

-- === BEGIN MIGRATION: 0104_life_goals_extended.sql ===
-- Migration: Extended Life Goals with Steps, Substeps, and Alerts
-- This migration adds support for detailed life goals with steps, timing, and PWA notifications

-- Create life_goal_steps table for managing goal steps
create table if not exists public.life_goal_steps (
  id uuid primary key default gen_random_uuid(),
  goal_id uuid not null references public.goals (id) on delete cascade,
  step_order int not null default 0,
  title text not null,
  description text,
  completed boolean not null default false,
  completed_at timestamptz,
  due_date date,
  created_at timestamptz not null default timezone('utc', now())
);

-- Create life_goal_substeps table for managing substeps
create table if not exists public.life_goal_substeps (
  id uuid primary key default gen_random_uuid(),
  step_id uuid not null references public.life_goal_steps (id) on delete cascade,
  substep_order int not null default 0,
  title text not null,
  completed boolean not null default false,
  completed_at timestamptz,
  created_at timestamptz not null default timezone('utc', now())
);

-- Create life_goal_alerts table for managing goal alerts and notifications
create table if not exists public.life_goal_alerts (
  id uuid primary key default gen_random_uuid(),
  goal_id uuid not null references public.goals (id) on delete cascade,
  user_id uuid not null references auth.users (id) on delete cascade,
  alert_type text not null, -- 'milestone', 'deadline', 'reminder', 'custom'
  alert_time timestamptz not null,
  title text not null,
  message text,
  sent boolean not null default false,
  sent_at timestamptz,
  repeat_pattern text, -- 'once', 'daily', 'weekly', 'monthly'
  enabled boolean not null default true,
  created_at timestamptz not null default timezone('utc', now())
);

-- Add new columns to goals table for extended features
alter table public.goals
  add column if not exists life_wheel_category text,
  add column if not exists start_date date,
  add column if not exists timing_notes text,
  add column if not exists estimated_duration_days int;

-- Create index for faster queries
create index if not exists life_goal_steps_goal_id_idx on public.life_goal_steps (goal_id);
create index if not exists life_goal_substeps_step_id_idx on public.life_goal_substeps (step_id);
create index if not exists life_goal_alerts_goal_id_idx on public.life_goal_alerts (goal_id);
create index if not exists life_goal_alerts_user_id_idx on public.life_goal_alerts (user_id);
create index if not exists life_goal_alerts_alert_time_idx on public.life_goal_alerts (alert_time);
create index if not exists goals_life_wheel_category_idx on public.goals (life_wheel_category);

-- Add RLS policies for life_goal_steps
alter table public.life_goal_steps enable row level security;

drop policy if exists "Users can view steps for their own goals" on public.life_goal_steps;
create policy "Users can view steps for their own goals"
  on public.life_goal_steps for select
  using (
    exists (
      select 1 from public.goals
      where goals.id = life_goal_steps.goal_id
      and goals.user_id = auth.uid()
    )
  );

drop policy if exists "Users can insert steps for their own goals" on public.life_goal_steps;
create policy "Users can insert steps for their own goals"
  on public.life_goal_steps for insert
  with check (
    exists (
      select 1 from public.goals
      where goals.id = life_goal_steps.goal_id
      and goals.user_id = auth.uid()
    )
  );

drop policy if exists "Users can update steps for their own goals" on public.life_goal_steps;
create policy "Users can update steps for their own goals"
  on public.life_goal_steps for update
  using (
    exists (
      select 1 from public.goals
      where goals.id = life_goal_steps.goal_id
      and goals.user_id = auth.uid()
    )
  );

drop policy if exists "Users can delete steps for their own goals" on public.life_goal_steps;
create policy "Users can delete steps for their own goals"
  on public.life_goal_steps for delete
  using (
    exists (
      select 1 from public.goals
      where goals.id = life_goal_steps.goal_id
      and goals.user_id = auth.uid()
    )
  );

-- Add RLS policies for life_goal_substeps
alter table public.life_goal_substeps enable row level security;

drop policy if exists "Users can view substeps for their own goals" on public.life_goal_substeps;
create policy "Users can view substeps for their own goals"
  on public.life_goal_substeps for select
  using (
    exists (
      select 1 from public.life_goal_steps
      join public.goals on goals.id = life_goal_steps.goal_id
      where life_goal_steps.id = life_goal_substeps.step_id
      and goals.user_id = auth.uid()
    )
  );

drop policy if exists "Users can insert substeps for their own goals" on public.life_goal_substeps;
create policy "Users can insert substeps for their own goals"
  on public.life_goal_substeps for insert
  with check (
    exists (
      select 1 from public.life_goal_steps
      join public.goals on goals.id = life_goal_steps.goal_id
      where life_goal_steps.id = life_goal_substeps.step_id
      and goals.user_id = auth.uid()
    )
  );

drop policy if exists "Users can update substeps for their own goals" on public.life_goal_substeps;
create policy "Users can update substeps for their own goals"
  on public.life_goal_substeps for update
  using (
    exists (
      select 1 from public.life_goal_steps
      join public.goals on goals.id = life_goal_steps.goal_id
      where life_goal_steps.id = life_goal_substeps.step_id
      and goals.user_id = auth.uid()
    )
  );

drop policy if exists "Users can delete substeps for their own goals" on public.life_goal_substeps;
create policy "Users can delete substeps for their own goals"
  on public.life_goal_substeps for delete
  using (
    exists (
      select 1 from public.life_goal_steps
      join public.goals on goals.id = life_goal_steps.goal_id
      where life_goal_steps.id = life_goal_substeps.step_id
      and goals.user_id = auth.uid()
    )
  );

-- Add RLS policies for life_goal_alerts
alter table public.life_goal_alerts enable row level security;

drop policy if exists "Users can view their own goal alerts" on public.life_goal_alerts;
create policy "Users can view their own goal alerts"
  on public.life_goal_alerts for select
  using (user_id = auth.uid());

drop policy if exists "Users can insert their own goal alerts" on public.life_goal_alerts;
create policy "Users can insert their own goal alerts"
  on public.life_goal_alerts for insert
  with check (user_id = auth.uid());

drop policy if exists "Users can update their own goal alerts" on public.life_goal_alerts;
create policy "Users can update their own goal alerts"
  on public.life_goal_alerts for update
  using (user_id = auth.uid());

drop policy if exists "Users can delete their own goal alerts" on public.life_goal_alerts;
create policy "Users can delete their own goal alerts"
  on public.life_goal_alerts for delete
  using (user_id = auth.uid());

-- Add comments for documentation
comment on table public.life_goal_steps is 'Steps for breaking down life goals into actionable tasks';
comment on table public.life_goal_substeps is 'Substeps for further breaking down goal steps';
comment on table public.life_goal_alerts is 'Alert and notification schedules for life goals (PWA compatible)';
comment on column public.goals.life_wheel_category is 'Links goal to a life wheel category (spirituality_community, finance_wealth, etc.)';
comment on column public.goals.start_date is 'When the user plans to start working on this goal';
comment on column public.goals.timing_notes is 'Detailed timing and schedule notes for the goal';
comment on column public.goals.estimated_duration_days is 'Estimated number of days to complete this goal';
-- === END MIGRATION: 0104_life_goals_extended.sql ===

-- === BEGIN MIGRATION: 0105_vision_images_url_support.sql ===
-- Add support for URL-based images in vision_images table
-- This migration adds columns to support both file uploads and external URLs

-- Add image_url column to store external image URLs
alter table public.vision_images add column if not exists image_url text;

-- Add image_source column to track whether the image is from a file or URL
-- Default to 'file' for backward compatibility with existing records
alter table public.vision_images add column if not exists image_source text default 'file';

-- Add check constraint to ensure image_source is either 'file' or 'url'
do $$ 
begin
  if not exists (
    select 1 from pg_constraint 
    where conname = 'vision_images_source_check' 
    and conrelid = 'public.vision_images'::regclass
  ) then
    alter table public.vision_images 
    add constraint vision_images_source_check 
    check (image_source in ('file', 'url'));
  end if;
end $$;

-- Add check constraint to ensure either image_path or image_url is set based on source
do $$ 
begin
  if not exists (
    select 1 from pg_constraint 
    where conname = 'vision_images_path_url_check' 
    and conrelid = 'public.vision_images'::regclass
  ) then
    alter table public.vision_images 
    add constraint vision_images_path_url_check 
    check (
      (image_source = 'file' and image_path is not null) or
      (image_source = 'url' and image_url is not null)
    );
  end if;
end $$;

-- Comment the columns for documentation
comment on column public.vision_images.image_url is 'External URL for images loaded from the web';
comment on column public.vision_images.image_source is 'Source type: file (uploaded to storage) or url (external link)';
-- === END MIGRATION: 0105_vision_images_url_support.sql ===

-- === BEGIN MIGRATION: 0106_journal_feature.sql ===
-- Journal entries table and policies

-- Ensure pgcrypto for gen_random_uuid
DO $$
BEGIN
  PERFORM gen_random_uuid();
EXCEPTION
  WHEN undefined_function THEN
    CREATE EXTENSION IF NOT EXISTS pgcrypto;
END$$;

-- Helper function to maintain updated_at
CREATE OR REPLACE FUNCTION public.set_journal_updated_at()
RETURNS trigger AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TABLE IF NOT EXISTS public.journal_entries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  entry_date date NOT NULL DEFAULT current_date,
  title text,
  content text NOT NULL,
  mood text,
  tags text[] DEFAULT '{}',
  is_private boolean NOT NULL DEFAULT true,
  attachments jsonb,
  linked_goal_ids text[] DEFAULT '{}',
  linked_habit_ids text[] DEFAULT '{}'
);

DROP TRIGGER IF EXISTS set_journal_entries_updated_at ON public.journal_entries;
CREATE TRIGGER set_journal_entries_updated_at
BEFORE UPDATE ON public.journal_entries
FOR EACH ROW
EXECUTE FUNCTION public.set_journal_updated_at();

ALTER TABLE public.journal_entries ENABLE ROW LEVEL SECURITY;

DO $$
BEGIN
  IF EXISTS (
    SELECT 1
    FROM pg_policies
    WHERE schemaname = 'public'
      AND tablename = 'journal_entries'
      AND policyname = 'own journal entries'
  ) THEN
    EXECUTE 'DROP POLICY "own journal entries" ON public.journal_entries';
  END IF;
END$$;

CREATE POLICY "own journal entries" ON public.journal_entries
  FOR ALL
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);
-- === END MIGRATION: 0106_journal_feature.sql ===

-- === BEGIN MIGRATION: 0107_workspace_profiles.sql ===
-- Workspace profiles table
-- Backfill workspace_profiles schema to match production fixes.
-- This ensures the upsert with onConflict: 'user_id' works correctly.

-- Create workspace_profiles table
CREATE TABLE IF NOT EXISTS public.workspace_profiles (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  display_name text,
  full_name text,
  workspace_name text,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

-- Create unique index on user_id to support onConflict upserts
-- This fixes the error: "there is no unique or exclusion constraint matching the ON CONFLICT specification"
CREATE UNIQUE INDEX IF NOT EXISTS workspace_profiles_user_id_key 
ON public.workspace_profiles (user_id);

-- Enable RLS
ALTER TABLE public.workspace_profiles ENABLE ROW LEVEL SECURITY;

-- Drop existing policy if it exists
DO $$
BEGIN
  IF EXISTS (
    SELECT 1
    FROM pg_policies
    WHERE schemaname = 'public'
      AND tablename = 'workspace_profiles'
      AND policyname = 'workspace_profiles_owner_all'
  ) THEN
    EXECUTE 'DROP POLICY "workspace_profiles_owner_all" ON public.workspace_profiles';
  END IF;
END$$;

-- Create RLS policy: users can only access their own workspace profile
CREATE POLICY "workspace_profiles_owner_all" 
ON public.workspace_profiles
AS PERMISSIVE
FOR ALL
TO public
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);
-- === END MIGRATION: 0107_workspace_profiles.sql ===

-- === BEGIN MIGRATION: 0108_add_initials.sql ===
-- Add initials field to workspace_profiles table
-- Initials are auto-generated from the first two word letters of full_name

ALTER TABLE public.workspace_profiles
ADD COLUMN IF NOT EXISTS initials text;

-- Add preference for showing initials in main menu icon
ALTER TABLE public.workspace_profiles
ADD COLUMN IF NOT EXISTS show_initials_in_menu boolean DEFAULT false;

-- Add comment to document the fields
COMMENT ON COLUMN public.workspace_profiles.initials IS 'Auto-generated initials from the first two word letters of full_name';
COMMENT ON COLUMN public.workspace_profiles.show_initials_in_menu IS 'User preference to show initials instead of default icon in main menu';
-- === END MIGRATION: 0108_add_initials.sql ===

-- === BEGIN MIGRATION: 0108_ai_settings.sql ===
-- Migration: AI Settings
-- Description: Create ai_settings table for user-specific AI configurations
-- Required for: AI-powered goal suggestions and other AI features

-- Create ai_settings table
CREATE TABLE IF NOT EXISTS ai_settings (
  user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  provider TEXT NOT NULL DEFAULT 'openai',
  api_key TEXT,
  model TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add index on user_id for faster lookups
CREATE INDEX IF NOT EXISTS idx_ai_settings_user_id ON ai_settings(user_id);

-- Add index on provider for potential multi-provider support
CREATE INDEX IF NOT EXISTS idx_ai_settings_provider ON ai_settings(provider);

-- Enable Row Level Security
ALTER TABLE ai_settings ENABLE ROW LEVEL SECURITY;

-- Policy: Users can only read their own AI settings
CREATE POLICY "Users can view their own AI settings"
  ON ai_settings
  FOR SELECT
  USING (auth.uid() = user_id);

-- Policy: Users can insert their own AI settings
CREATE POLICY "Users can insert their own AI settings"
  ON ai_settings
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Policy: Users can update their own AI settings
CREATE POLICY "Users can update their own AI settings"
  ON ai_settings
  FOR UPDATE
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Policy: Users can delete their own AI settings
CREATE POLICY "Users can delete their own AI settings"
  ON ai_settings
  FOR DELETE
  USING (auth.uid() = user_id);

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_ai_settings_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically update updated_at
CREATE TRIGGER update_ai_settings_updated_at
  BEFORE UPDATE ON ai_settings
  FOR EACH ROW
  EXECUTE FUNCTION update_ai_settings_updated_at();

-- Add comments for documentation
COMMENT ON TABLE ai_settings IS 'User-specific AI provider configurations and API keys';
COMMENT ON COLUMN ai_settings.user_id IS 'Reference to the user who owns this configuration';
COMMENT ON COLUMN ai_settings.provider IS 'AI provider name (e.g., openai, anthropic)';
COMMENT ON COLUMN ai_settings.api_key IS 'User-provided API key for the AI provider (encrypted at rest)';
COMMENT ON COLUMN ai_settings.model IS 'Preferred AI model for this user (e.g., gpt-4o-mini, gpt-4o)';
COMMENT ON COLUMN ai_settings.created_at IS 'Timestamp when the settings were created';
COMMENT ON COLUMN ai_settings.updated_at IS 'Timestamp when the settings were last updated';
-- === END MIGRATION: 0108_ai_settings.sql ===

-- === BEGIN MIGRATION: 0109_habit_completions.sql ===
-- ========================================================
-- HABIT COMPLETIONS TABLE
-- Migration 0109: Per-day habit completion tracking (Path B)
-- ========================================================

-- Create habit_completions table
create table if not exists public.habit_completions (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  habit_id uuid not null references public.habits_v2(id) on delete cascade,
  completed_date date not null,
  completed boolean not null default true,
  created_at timestamptz not null default now(),
  unique (user_id, habit_id, completed_date)
);

-- Create indexes for better query performance
create index if not exists idx_habit_completions_user_id on public.habit_completions(user_id);
create index if not exists idx_habit_completions_habit_id on public.habit_completions(habit_id);
create index if not exists idx_habit_completions_date on public.habit_completions(completed_date);
create index if not exists idx_habit_completions_user_habit on public.habit_completions(user_id, habit_id);

-- Enable Row Level Security
alter table public.habit_completions enable row level security;

-- RLS Policy: Users can only access their own habit completions
drop policy if exists "own habit completions" on public.habit_completions;
create policy "own habit completions" on public.habit_completions
  for all using (auth.uid() = user_id) with check (auth.uid() = user_id);
-- === END MIGRATION: 0109_habit_completions.sql ===

-- === BEGIN MIGRATION: 0110_meditation_sessions.sql ===
-- Meditation sessions table and policies

-- Ensure pgcrypto for gen_random_uuid
DO $$
BEGIN
  PERFORM gen_random_uuid();
EXCEPTION
  WHEN undefined_function THEN
    CREATE EXTENSION IF NOT EXISTS pgcrypto;
END$$;

CREATE TABLE IF NOT EXISTS public.meditation_sessions (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  created_at timestamptz NOT NULL DEFAULT now(),
  session_date date NOT NULL DEFAULT current_date,
  session_type text NOT NULL DEFAULT 'breathing',
  duration_seconds integer NOT NULL,
  completed boolean NOT NULL DEFAULT true,
  notes text,
  CONSTRAINT meditation_sessions_duration_positive CHECK (duration_seconds > 0)
);

-- Enable RLS
ALTER TABLE public.meditation_sessions ENABLE ROW LEVEL SECURITY;

-- Drop existing policy if it exists
DO $$
BEGIN
  IF EXISTS (
    SELECT 1
    FROM pg_policies
    WHERE schemaname = 'public'
      AND tablename = 'meditation_sessions'
      AND policyname = 'own meditation sessions'
  ) THEN
    EXECUTE 'DROP POLICY "own meditation sessions" ON public.meditation_sessions';
  END IF;
END$$;

-- Create policy: users can only access their own meditation sessions
CREATE POLICY "own meditation sessions" ON public.meditation_sessions
  FOR ALL
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Create indexes for better query performance
CREATE INDEX IF NOT EXISTS idx_meditation_sessions_user_id ON public.meditation_sessions(user_id);
CREATE INDEX IF NOT EXISTS idx_meditation_sessions_session_date ON public.meditation_sessions(session_date DESC);

-- Add helpful comments
COMMENT ON TABLE public.meditation_sessions IS 'Stores completed meditation and breathing sessions for users';
COMMENT ON COLUMN public.meditation_sessions.session_type IS 'Type of meditation session (breathing, guided, etc.)';
COMMENT ON COLUMN public.meditation_sessions.duration_seconds IS 'Duration of the session in seconds';
COMMENT ON COLUMN public.meditation_sessions.completed IS 'Whether the session was completed or abandoned';
-- === END MIGRATION: 0110_meditation_sessions.sql ===

-- === BEGIN MIGRATION: 0111_meditation_reminders.sql ===
-- Meditation reminders table and policies

-- Ensure pgcrypto for gen_random_uuid
DO $$
BEGIN
  PERFORM gen_random_uuid();
EXCEPTION
  WHEN undefined_function THEN
    CREATE EXTENSION IF NOT EXISTS pgcrypto;
END$$;

-- Helper function to maintain updated_at
CREATE OR REPLACE FUNCTION public.set_meditation_reminders_updated_at()
RETURNS trigger AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TABLE IF NOT EXISTS public.meditation_reminders (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  enabled boolean NOT NULL DEFAULT true,
  time_of_day text NOT NULL DEFAULT '08:00',
  timezone text,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

-- Add index on user_id for fast lookups
CREATE INDEX IF NOT EXISTS idx_meditation_reminders_user_id ON public.meditation_reminders(user_id);

DROP TRIGGER IF EXISTS set_meditation_reminders_updated_at ON public.meditation_reminders;
CREATE TRIGGER set_meditation_reminders_updated_at
BEFORE UPDATE ON public.meditation_reminders
FOR EACH ROW
EXECUTE FUNCTION public.set_meditation_reminders_updated_at();

ALTER TABLE public.meditation_reminders ENABLE ROW LEVEL SECURITY;

DO $$
BEGIN
  IF EXISTS (
    SELECT 1
    FROM pg_policies
    WHERE schemaname = 'public'
      AND tablename = 'meditation_reminders'
      AND policyname = 'own meditation reminders'
  ) THEN
    EXECUTE 'DROP POLICY "own meditation reminders" ON public.meditation_reminders';
  END IF;
END$$;

CREATE POLICY "own meditation reminders" ON public.meditation_reminders
  FOR ALL
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Add helpful comments
COMMENT ON TABLE public.meditation_reminders IS 'Stores daily reminder preferences for meditation/breathing space feature';
COMMENT ON COLUMN public.meditation_reminders.enabled IS 'Whether the daily reminder is enabled';
COMMENT ON COLUMN public.meditation_reminders.time_of_day IS 'Time of day for the reminder in HH:MM format';
COMMENT ON COLUMN public.meditation_reminders.timezone IS 'User timezone for scheduling (optional)';
-- === END MIGRATION: 0111_meditation_reminders.sql ===

-- === BEGIN MIGRATION: 0112_journal_modes.sql ===
-- Migration 0112: Add support for multiple journal modes
-- Original path: sql/006_journal_modes.sql
-- This migration extends the journal_entries table to support different journaling modes
-- (quick, deep, brain_dump, life_wheel, secret, goal, time_capsule, standard)

-- Add new columns to journal_entries table
ALTER TABLE public.journal_entries
ADD COLUMN IF NOT EXISTS type text NOT NULL DEFAULT 'standard';

-- Numeric mood score on a 0-10 scale
-- Note: Using integer type to enforce whole numbers only (no fractional scores)
ALTER TABLE public.journal_entries
ADD COLUMN IF NOT EXISTS mood_score integer;

ALTER TABLE public.journal_entries
ADD COLUMN IF NOT EXISTS category text;

ALTER TABLE public.journal_entries
ADD COLUMN IF NOT EXISTS unlock_date timestamptz;

ALTER TABLE public.journal_entries
ADD COLUMN IF NOT EXISTS goal_id uuid;

-- Add constraints for data validation
-- Mood score should be between 0 and 10 if provided
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint 
    WHERE conname = 'journal_entries_mood_score_range'
    AND conrelid = 'public.journal_entries'::regclass
  ) THEN
    ALTER TABLE public.journal_entries
    ADD CONSTRAINT journal_entries_mood_score_range
    CHECK (mood_score IS NULL OR (mood_score >= 0 AND mood_score <= 10));
  END IF;
END $$;

-- Type should be one of the valid journal modes
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint 
    WHERE conname = 'journal_entries_type_allowed_values'
    AND conrelid = 'public.journal_entries'::regclass
  ) THEN
    ALTER TABLE public.journal_entries
    ADD CONSTRAINT journal_entries_type_allowed_values
    CHECK (type IN ('quick', 'deep', 'brain_dump', 'life_wheel', 'secret', 'goal', 'time_capsule', 'standard'));
  END IF;
END $$;

-- Foreign key constraint for goal_id
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint 
    WHERE conname = 'journal_entries_goal_id_fkey'
    AND conrelid = 'public.journal_entries'::regclass
  ) THEN
    ALTER TABLE public.journal_entries
    ADD CONSTRAINT journal_entries_goal_id_fkey
    FOREIGN KEY (goal_id) REFERENCES public.goals(id) ON DELETE SET NULL;
  END IF;
END $$;

-- Create an index on type for better query performance
CREATE INDEX IF NOT EXISTS idx_journal_entries_type ON public.journal_entries(type);

-- Create an index on goal_id for better query performance when filtering by goal
CREATE INDEX IF NOT EXISTS idx_journal_entries_goal_id ON public.journal_entries(goal_id);

-- Create an index on unlock_date for time capsule entries
CREATE INDEX IF NOT EXISTS idx_journal_entries_unlock_date ON public.journal_entries(unlock_date)
WHERE unlock_date IS NOT NULL;

-- Add comment to document the new fields
COMMENT ON COLUMN public.journal_entries.type IS 'Journal entry mode: quick, deep, brain_dump, life_wheel, secret, goal, time_capsule, or standard';
COMMENT ON COLUMN public.journal_entries.mood_score IS 'Numeric mood score on a 0-10 scale (separate from the string mood field)';
COMMENT ON COLUMN public.journal_entries.category IS 'Life Wheel category for life_wheel journal mode';
COMMENT ON COLUMN public.journal_entries.unlock_date IS 'Date when a time capsule entry becomes visible';
COMMENT ON COLUMN public.journal_entries.goal_id IS 'Primary goal reference for goal-specific journal entries. Use this for entries focused on a single goal. For entries that reference multiple goals, use the linked_goal_ids array instead.';
-- === END MIGRATION: 0112_journal_modes.sql ===

-- === BEGIN MIGRATION: 0113_vision_images_file_metadata.sql ===
-- Migration 0113: Add file metadata columns to vision_images table
-- This migration adds columns to store file paths and formats for uploaded images

-- Add file_path column (for storing the original file path before WebP conversion)
ALTER TABLE public.vision_images ADD COLUMN IF NOT EXISTS file_path TEXT;

-- Add file_format column (for storing the original file format, e.g., 'jpeg', 'png', 'webp')
ALTER TABLE public.vision_images ADD COLUMN IF NOT EXISTS file_format TEXT;

-- Add index on file_format for potential filtering/reporting
CREATE INDEX IF NOT EXISTS idx_vision_images_file_format ON public.vision_images(file_format);

-- Comment the columns for documentation
COMMENT ON COLUMN public.vision_images.file_path IS 'Original file path in storage (before WebP conversion if applicable)';
COMMENT ON COLUMN public.vision_images.file_format IS 'Original file format (e.g., jpeg, png, webp)';
-- === END MIGRATION: 0113_vision_images_file_metadata.sql ===

-- === BEGIN MIGRATION: 0114_problem_journal_type.sql ===
-- Migration 0114: Add 'problem' journal type with dedicated sections
-- This migration adds support for the Problem journal mode which includes:
-- 1. Brain dump section (uses existing content field with self-destruct in UI)
-- 2. Irrational fears section (preserved)
-- 3. Training on solutions section (preserved)
-- 4. Concrete steps section (preserved)

-- Add new columns for Problem journal sections
ALTER TABLE public.journal_entries
ADD COLUMN IF NOT EXISTS irrational_fears text;

ALTER TABLE public.journal_entries
ADD COLUMN IF NOT EXISTS training_solutions text;

ALTER TABLE public.journal_entries
ADD COLUMN IF NOT EXISTS concrete_steps text;

-- Update the type constraint to include 'problem'
-- First, drop the existing constraint
DO $$
BEGIN
  IF EXISTS (
    SELECT 1 FROM pg_constraint 
    WHERE conname = 'journal_entries_type_allowed_values'
    AND conrelid = 'public.journal_entries'::regclass
  ) THEN
    ALTER TABLE public.journal_entries
    DROP CONSTRAINT journal_entries_type_allowed_values;
  END IF;
END $$;

-- Add the updated constraint with 'problem' included
ALTER TABLE public.journal_entries
ADD CONSTRAINT journal_entries_type_allowed_values
CHECK (type IN ('quick', 'deep', 'brain_dump', 'life_wheel', 'secret', 'goal', 'time_capsule', 'standard', 'problem'));

-- Add comments to document the new fields
COMMENT ON COLUMN public.journal_entries.irrational_fears IS 'Problem journal mode: Section for identifying and acknowledging potential irrational fears';
COMMENT ON COLUMN public.journal_entries.training_solutions IS 'Problem journal mode: Section for writing dialogues, visualizing solutions, or practicing resolutions';
COMMENT ON COLUMN public.journal_entries.concrete_steps IS 'Problem journal mode: Section for actionable steps based on personality types (alarms, appointments, hints)';
-- === END MIGRATION: 0114_problem_journal_type.sql ===

-- === BEGIN MIGRATION: 0114_vision_images_review_metadata.sql ===
-- Migration 0114: Add metadata + review loop fields to vision_images

ALTER TABLE public.vision_images
  ADD COLUMN IF NOT EXISTS vision_type TEXT;

ALTER TABLE public.vision_images
  ADD COLUMN IF NOT EXISTS review_interval_days INTEGER DEFAULT 30;

ALTER TABLE public.vision_images
  ADD COLUMN IF NOT EXISTS last_reviewed_at TIMESTAMPTZ;

ALTER TABLE public.vision_images
  ADD COLUMN IF NOT EXISTS linked_goal_ids TEXT[];

ALTER TABLE public.vision_images
  ADD COLUMN IF NOT EXISTS linked_habit_ids TEXT[];

COMMENT ON COLUMN public.vision_images.vision_type IS 'Classification for the vision board entry (goal, habit, identity, experience, environment).';
COMMENT ON COLUMN public.vision_images.review_interval_days IS 'Number of days between review check-ins for a vision board item.';
COMMENT ON COLUMN public.vision_images.last_reviewed_at IS 'Timestamp of the most recent review check-in.';
COMMENT ON COLUMN public.vision_images.linked_goal_ids IS 'Goal IDs linked to this vision board entry.';
COMMENT ON COLUMN public.vision_images.linked_habit_ids IS 'Habit IDs linked to this vision board entry.';
-- === END MIGRATION: 0114_vision_images_review_metadata.sql ===

-- === BEGIN MIGRATION: 0115_gamification_system.sql ===
-- Migration: Gamification System (Phase 1)
-- Description: Create comprehensive gamification system with XP, levels, achievements, streaks
-- Inspired by: Duolingo, Monopoly GO, Angry Birds

-- =====================================================
-- 1. GAMIFICATION PROFILES TABLE
-- =====================================================
CREATE TABLE IF NOT EXISTS gamification_profiles (
  user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  total_xp INT NOT NULL DEFAULT 0,
  current_level INT NOT NULL DEFAULT 1,
  current_streak INT NOT NULL DEFAULT 0,
  longest_streak INT NOT NULL DEFAULT 0,
  last_activity_date DATE,
  lives INT NOT NULL DEFAULT 5,
  max_lives INT NOT NULL DEFAULT 5,
  last_life_refill TIMESTAMPTZ,
  streak_freezes INT NOT NULL DEFAULT 0,
  total_points INT NOT NULL DEFAULT 0,
  gamification_enabled BOOLEAN NOT NULL DEFAULT TRUE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- =====================================================
-- 2. ACHIEVEMENTS TABLE
-- =====================================================
CREATE TABLE IF NOT EXISTS achievements (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  achievement_key TEXT UNIQUE NOT NULL,
  name TEXT NOT NULL,
  description TEXT NOT NULL,
  icon TEXT NOT NULL,
  tier TEXT NOT NULL CHECK (tier IN ('bronze', 'silver', 'gold', 'diamond')),
  category TEXT NOT NULL CHECK (category IN ('streak', 'habit', 'goal', 'journal', 'general')),
  xp_reward INT NOT NULL DEFAULT 0,
  requirement_type TEXT NOT NULL,
  requirement_value INT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- =====================================================
-- 3. USER ACHIEVEMENTS TABLE
-- =====================================================
CREATE TABLE IF NOT EXISTS user_achievements (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  achievement_id UUID NOT NULL REFERENCES achievements(id) ON DELETE CASCADE,
  progress INT NOT NULL DEFAULT 0,
  unlocked BOOLEAN NOT NULL DEFAULT FALSE,
  unlocked_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(user_id, achievement_id)
);

-- =====================================================
-- 4. XP TRANSACTIONS TABLE
-- =====================================================
CREATE TABLE IF NOT EXISTS xp_transactions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  xp_amount INT NOT NULL,
  source_type TEXT NOT NULL,
  source_id TEXT,
  description TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- =====================================================
-- 5. GAMIFICATION NOTIFICATIONS TABLE
-- =====================================================
CREATE TABLE IF NOT EXISTS gamification_notifications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  notification_type TEXT NOT NULL CHECK (notification_type IN ('level_up', 'achievement_unlock', 'streak_milestone', 'life_refill')),
  title TEXT NOT NULL,
  message TEXT NOT NULL,
  icon TEXT,
  xp_reward INT DEFAULT 0,
  achievement_id UUID REFERENCES achievements(id) ON DELETE SET NULL,
  is_read BOOLEAN NOT NULL DEFAULT FALSE,
  is_dismissed BOOLEAN NOT NULL DEFAULT FALSE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- =====================================================
-- INDEXES FOR PERFORMANCE
-- =====================================================
CREATE INDEX IF NOT EXISTS idx_gamification_profiles_user_id ON gamification_profiles(user_id);
CREATE INDEX IF NOT EXISTS idx_achievements_category ON achievements(category);
CREATE INDEX IF NOT EXISTS idx_achievements_tier ON achievements(tier);
CREATE INDEX IF NOT EXISTS idx_user_achievements_user_id ON user_achievements(user_id);
CREATE INDEX IF NOT EXISTS idx_user_achievements_unlocked ON user_achievements(user_id, unlocked);
CREATE INDEX IF NOT EXISTS idx_xp_transactions_user_id ON xp_transactions(user_id);
CREATE INDEX IF NOT EXISTS idx_xp_transactions_created_at ON xp_transactions(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_gamification_notifications_user_id ON gamification_notifications(user_id);
CREATE INDEX IF NOT EXISTS idx_gamification_notifications_unread ON gamification_notifications(user_id, is_read, is_dismissed);

-- =====================================================
-- ROW LEVEL SECURITY POLICIES
-- =====================================================

-- Enable RLS
ALTER TABLE gamification_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE achievements ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_achievements ENABLE ROW LEVEL SECURITY;
ALTER TABLE xp_transactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE gamification_notifications ENABLE ROW LEVEL SECURITY;

-- Gamification Profiles Policies
CREATE POLICY "Users can view their own gamification profile"
  ON gamification_profiles FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own gamification profile"
  ON gamification_profiles FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own gamification profile"
  ON gamification_profiles FOR UPDATE
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Achievements Policies (public read, no write)
CREATE POLICY "Anyone can view achievements"
  ON achievements FOR SELECT
  USING (true);

-- User Achievements Policies
CREATE POLICY "Users can view their own achievements"
  ON user_achievements FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own achievements"
  ON user_achievements FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own achievements"
  ON user_achievements FOR UPDATE
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- XP Transactions Policies
CREATE POLICY "Users can view their own XP transactions"
  ON xp_transactions FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own XP transactions"
  ON xp_transactions FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Gamification Notifications Policies
CREATE POLICY "Users can view their own notifications"
  ON gamification_notifications FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own notifications"
  ON gamification_notifications FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own notifications"
  ON gamification_notifications FOR UPDATE
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete their own notifications"
  ON gamification_notifications FOR DELETE
  USING (auth.uid() = user_id);

-- =====================================================
-- TRIGGERS FOR UPDATED_AT
-- =====================================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_gamification_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Triggers
CREATE TRIGGER update_gamification_profiles_updated_at
  BEFORE UPDATE ON gamification_profiles
  FOR EACH ROW
  EXECUTE FUNCTION update_gamification_updated_at();

CREATE TRIGGER update_user_achievements_updated_at
  BEFORE UPDATE ON user_achievements
  FOR EACH ROW
  EXECUTE FUNCTION update_gamification_updated_at();

-- =====================================================
-- SEED DATA: 10 STARTER ACHIEVEMENTS
-- =====================================================

INSERT INTO achievements (achievement_key, name, description, icon, tier, category, xp_reward, requirement_type, requirement_value)
VALUES
  -- Streak Achievements
  ('week_warrior', 'Week Warrior', 'Maintain a 7-day streak', '🔥', 'bronze', 'streak', 100, 'streak', 7),
  ('fortnight_fighter', 'Fortnight Fighter', 'Maintain a 14-day streak', '💪', 'bronze', 'streak', 200, 'streak', 14),
  ('consistency_king', 'Consistency King', 'Maintain a 30-day streak', '👑', 'gold', 'streak', 500, 'streak', 30),
  ('century_streak', 'Century Streak', 'Maintain a 100-day streak', '💯', 'diamond', 'streak', 1000, 'streak', 100),
  
  -- Habit Achievements
  ('getting_started', 'Getting Started', 'Complete your first habit', '✅', 'bronze', 'habit', 10, 'habits_completed', 1),
  ('habit_builder', 'Habit Builder', 'Complete 10 habits', '📋', 'bronze', 'habit', 50, 'habits_completed', 10),
  ('consistency_pro', 'Consistency Pro', 'Complete 50 habits', '⭐', 'silver', 'habit', 150, 'habits_completed', 50),
  ('century_club', 'Century Club', 'Complete 100 habits', '💯', 'silver', 'habit', 300, 'habits_completed', 100),
  
  -- Goal Achievements
  ('visionary', 'Visionary', 'Achieve your first goal', '🎯', 'bronze', 'goal', 50, 'goals_achieved', 1),
  ('goal_crusher', 'Goal Crusher', 'Achieve 5 goals', '🏆', 'gold', 'goal', 400, 'goals_achieved', 5),
  
  -- Journal-based achievements
  ('reflection_master', 'Reflection Master', 'Write 30 journal entries', '📝', 'silver', 'journal', 200, 'journal_entries', 30),
  ('wordsmith', 'Wordsmith', 'Write 10 journal entries with 500+ words', '✍️', 'gold', 'journal', 300, 'journal_long_entries', 10),
  
  -- Check-in achievements  
  ('self_aware', 'Self-Aware', 'Complete your first life wheel check-in', '🧘', 'bronze', 'general', 30, 'checkins_completed', 1),
  ('balanced_life', 'Balanced Life', 'Complete 10 life wheel check-ins', '⚖️', 'silver', 'general', 150, 'checkins_completed', 10),
  
  -- Vision board achievements
  ('inspired', 'Inspired', 'Upload your first vision board image', '✨', 'bronze', 'general', 20, 'vision_uploads', 1),
  ('visionary_board', 'Vision Board Master', 'Upload 20 vision board images', '🖼️', 'silver', 'general', 200, 'vision_uploads', 20)
ON CONFLICT (achievement_key) DO NOTHING;

-- =====================================================
-- COMMENTS FOR DOCUMENTATION
-- =====================================================

COMMENT ON TABLE gamification_profiles IS 'User gamification data including XP, level, streaks, and preferences';
COMMENT ON TABLE achievements IS 'Available achievements/badges that users can unlock';
COMMENT ON TABLE user_achievements IS 'Tracks user progress and unlocked achievements';
COMMENT ON TABLE xp_transactions IS 'Audit log of all XP earned by users';
COMMENT ON TABLE gamification_notifications IS 'Notifications for achievements, level-ups, and milestones';

COMMENT ON COLUMN gamification_profiles.gamification_enabled IS 'Whether gamification features are shown to the user';
COMMENT ON COLUMN gamification_profiles.streak_freezes IS 'Number of streak freeze items available';
COMMENT ON COLUMN gamification_profiles.lives IS 'Current number of lives (for future features)';
COMMENT ON COLUMN achievements.tier IS 'Achievement tier: bronze, silver, gold, or diamond';
COMMENT ON COLUMN achievements.category IS 'Achievement category: streak, habit, goal, journal, or general';
-- === END MIGRATION: 0115_gamification_system.sql ===

-- === BEGIN MIGRATION: 0116_annual_reviews.sql ===
-- ========================================================
-- ANNUAL REVIEWS & GOALS - NEW YEAR'S MANIFEST FEATURE
-- Migration 0116: Annual Reviews, Goals, and Stats Function
-- ========================================================

-- Ensure pgcrypto for gen_random_uuid
DO $$
BEGIN
  PERFORM gen_random_uuid();
EXCEPTION
  WHEN undefined_function THEN
    CREATE EXTENSION IF NOT EXISTS pgcrypto;
END$$;

-- ========================================================
-- ANNUAL REVIEWS TABLE
-- Stores year-end reflections and overall ratings
-- ========================================================

CREATE TABLE IF NOT EXISTS public.annual_reviews (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  year int NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  reflection_text text,
  overall_rating int CHECK (overall_rating IS NULL OR (overall_rating >= 1 AND overall_rating <= 10)),
  UNIQUE (user_id, year)
);

-- Create indexes for better query performance
CREATE INDEX IF NOT EXISTS idx_annual_reviews_user_id ON public.annual_reviews(user_id);
CREATE INDEX IF NOT EXISTS idx_annual_reviews_year ON public.annual_reviews(year);

-- Enable RLS
ALTER TABLE public.annual_reviews ENABLE ROW LEVEL SECURITY;

-- RLS Policy: Users can only access their own annual reviews
DROP POLICY IF EXISTS "own annual reviews" ON public.annual_reviews;
CREATE POLICY "own annual reviews" ON public.annual_reviews
  FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

-- Add helpful comments
COMMENT ON TABLE public.annual_reviews IS 'Stores year-end reflections and ratings for the New Year Manifest feature';
COMMENT ON COLUMN public.annual_reviews.year IS 'The year being reviewed (e.g., 2024)';
COMMENT ON COLUMN public.annual_reviews.reflection_text IS 'User reflection text about the year';
COMMENT ON COLUMN public.annual_reviews.overall_rating IS 'Overall rating of the year from 1 to 10';

-- ========================================================
-- ANNUAL GOALS TABLE
-- Stores goals linked to annual reviews and Life Wheel categories
-- ========================================================

CREATE TABLE IF NOT EXISTS public.annual_goals (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  review_id uuid NOT NULL REFERENCES public.annual_reviews(id) ON DELETE CASCADE,
  category text NOT NULL,
  goal_statement text NOT NULL,
  vision_image_url text,
  created_at timestamptz NOT NULL DEFAULT now()
);

-- Create indexes for better query performance
CREATE INDEX IF NOT EXISTS idx_annual_goals_review_id ON public.annual_goals(review_id);
CREATE INDEX IF NOT EXISTS idx_annual_goals_category ON public.annual_goals(category);

-- Enable RLS
ALTER TABLE public.annual_goals ENABLE ROW LEVEL SECURITY;

-- RLS Policy: Users can only access annual goals for reviews they own
DROP POLICY IF EXISTS "own annual goals" ON public.annual_goals;
CREATE POLICY "own annual goals" ON public.annual_goals
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM public.annual_reviews
      WHERE annual_reviews.id = annual_goals.review_id
      AND annual_reviews.user_id = auth.uid()
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.annual_reviews
      WHERE annual_reviews.id = annual_goals.review_id
      AND annual_reviews.user_id = auth.uid()
    )
  );

-- Add helpful comments
COMMENT ON TABLE public.annual_goals IS 'Stores goals for each annual review, linked to Life Wheel categories';
COMMENT ON COLUMN public.annual_goals.category IS 'Life Wheel category (e.g., health, career, relationships, etc.)';
COMMENT ON COLUMN public.annual_goals.goal_statement IS 'The goal statement for this category';
COMMENT ON COLUMN public.annual_goals.vision_image_url IS 'Optional URL to vision board image for this goal';

-- ========================================================
-- GET_YEAR_IN_REVIEW_STATS RPC FUNCTION
-- Returns aggregated stats for a given year:
--   - Total habits completed: Count of habit completions within the year
--   - Longest streak: Overall best streak across all habits (not year-specific,
--     as streaks can span years; provides context on user consistency)
--   - Most active category: The Life Wheel category with most completions in the year
-- ========================================================

CREATE OR REPLACE FUNCTION public.get_year_in_review_stats(year_input int)
RETURNS TABLE (
  total_habits_completed bigint,
  longest_streak int,
  most_active_category text
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_start_date date;
  v_end_date date;
BEGIN
  -- Get current user
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;
  
  -- Calculate date range for the year
  v_start_date := make_date(year_input, 1, 1);
  v_end_date := make_date(year_input, 12, 31);
  
  RETURN QUERY
  WITH habit_completions_count AS (
    -- Count total habits completed in the year from habit_logs_v2
    SELECT COUNT(*) AS total_completed
    FROM public.habit_logs_v2
    WHERE user_id = v_user_id
      AND done = true
      AND date >= v_start_date
      AND date <= v_end_date
  ),
  streak_data AS (
    -- Get the longest streak from v_habit_streaks for user's habits
    SELECT COALESCE(MAX(vs.best_streak), 0) AS max_streak
    FROM public.v_habit_streaks vs
    INNER JOIN public.habits_v2 h ON h.id = vs.habit_id
    WHERE h.user_id = v_user_id
  ),
  category_activity AS (
    -- Find the most active category (domain_key) based on completed habits
    SELECT h.domain_key, COUNT(*) AS completion_count
    FROM public.habit_logs_v2 l
    INNER JOIN public.habits_v2 h ON h.id = l.habit_id
    WHERE l.user_id = v_user_id
      AND l.done = true
      AND l.date >= v_start_date
      AND l.date <= v_end_date
      AND h.domain_key IS NOT NULL
    GROUP BY h.domain_key
    ORDER BY completion_count DESC
    LIMIT 1
  )
  SELECT 
    hc.total_completed,
    sd.max_streak,
    ca.domain_key
  FROM habit_completions_count hc
  CROSS JOIN streak_data sd
  LEFT JOIN category_activity ca ON true;
END;
$$;

-- Grant execute permissions to authenticated users
GRANT EXECUTE ON FUNCTION public.get_year_in_review_stats(int) TO authenticated;

-- Add comment for documentation
COMMENT ON FUNCTION public.get_year_in_review_stats IS 'Returns aggregated stats for a given year: total habits completed (in-year), longest streak (overall best across all habits), and most active category (in-year)';
-- === END MIGRATION: 0116_annual_reviews.sql ===

-- === BEGIN MIGRATION: 0116_daily_spin_wheel.sql ===
-- ========================================================
-- DAILY SPIN WHEEL SYSTEM
-- Migration 0116: Daily reward spin mechanism
-- ========================================================

-- Daily spin state table
CREATE TABLE IF NOT EXISTS public.daily_spin_state (
  user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  last_spin_date DATE,
  spins_available INTEGER NOT NULL DEFAULT 0,
  total_spins_used INTEGER NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Spin history log
CREATE TABLE IF NOT EXISTS public.spin_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  prize_type TEXT NOT NULL, -- 'xp', 'points', 'streak_freeze', 'life', 'mystery'
  prize_value INTEGER NOT NULL,
  prize_details JSONB DEFAULT '{}'::jsonb, -- Extra data for mystery prizes
  spun_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_daily_spin_state_user_id ON public.daily_spin_state(user_id);
CREATE INDEX IF NOT EXISTS idx_daily_spin_state_last_spin ON public.daily_spin_state(last_spin_date);
CREATE INDEX IF NOT EXISTS idx_spin_history_user_id ON public.spin_history(user_id);
CREATE INDEX IF NOT EXISTS idx_spin_history_spun_at ON public.spin_history(spun_at DESC);

-- RLS Policies
ALTER TABLE public.daily_spin_state ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.spin_history ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view their own spin state" ON public.daily_spin_state;
CREATE POLICY "Users can view their own spin state"
  ON public.daily_spin_state FOR SELECT
  USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can insert their own spin state" ON public.daily_spin_state;
CREATE POLICY "Users can insert their own spin state"
  ON public.daily_spin_state FOR INSERT
  WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can update their own spin state" ON public.daily_spin_state;
CREATE POLICY "Users can update their own spin state"
  ON public.daily_spin_state FOR UPDATE
  USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can view their own spin history" ON public.spin_history;
CREATE POLICY "Users can view their own spin history"
  ON public.spin_history FOR SELECT
  USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can insert their own spin history" ON public.spin_history;
CREATE POLICY "Users can insert their own spin history"
  ON public.spin_history FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Add trigger for updated_at
CREATE TRIGGER update_daily_spin_state_updated_at
  BEFORE UPDATE ON public.daily_spin_state
  FOR EACH ROW
  EXECUTE FUNCTION update_gamification_updated_at();

-- Add new spin-based achievements
INSERT INTO public.achievements (achievement_key, name, description, icon, xp_reward, tier, category, requirement_type, requirement_value)
VALUES
  ('lucky_spinner', 'Lucky Spinner', 'Use the daily spin 7 times', '🎰', 100, 'bronze', 'general', 'spins_used', 7),
  ('spin_master', 'Spin Master', 'Use the daily spin 30 times', '🎯', 300, 'silver', 'general', 'spins_used', 30),
  ('jackpot', 'Jackpot!', 'Win the mystery prize from daily spin', '🎁', 200, 'gold', 'general', 'mystery_wins', 1)
ON CONFLICT (achievement_key) DO NOTHING;

-- Comments
COMMENT ON TABLE public.daily_spin_state IS 'Tracks daily spin availability and usage per user';
COMMENT ON TABLE public.spin_history IS 'Logs all spin results for analytics and achievement tracking';
-- === END MIGRATION: 0116_daily_spin_wheel.sql ===

-- === BEGIN MIGRATION: 0117_vision_board_daily_game.sql ===
-- Vision Board Daily Game tables
create table if not exists public.vision_board_daily_sessions (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users (id) on delete cascade,
  session_date date not null default (timezone('utc', now()))::date,
  status text not null default 'in_progress' check (status in ('in_progress','completed')),
  total_points integer,
  balance_score numeric,
  insight_area text,
  insight_text text,
  completed_at timestamptz,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  constraint vision_board_daily_sessions_user_date_key unique (user_id, session_date)
);

create index if not exists idx_vision_board_daily_sessions_user_date
  on public.vision_board_daily_sessions (user_id, session_date desc);

create table if not exists public.vision_board_daily_items (
  id uuid primary key default gen_random_uuid(),
  session_id uuid not null references public.vision_board_daily_sessions (id) on delete cascade,
  user_id uuid not null references auth.users (id) on delete cascade,
  title text,
  description text,
  suggested_area text,
  final_area text,
  order_index integer,
  status text not null default 'hidden' check (status in ('hidden','revealed','completed')),
  image_storage_path text,
  legacy_image_url text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index if not exists idx_vision_board_daily_items_session
  on public.vision_board_daily_items (session_id, order_index nulls last);

create index if not exists idx_vision_board_daily_items_user
  on public.vision_board_daily_items (user_id);

alter table public.vision_board_daily_sessions enable row level security;
alter table public.vision_board_daily_items enable row level security;

create policy vision_board_daily_sessions_select on public.vision_board_daily_sessions
  for select using (auth.uid() = user_id);

create policy vision_board_daily_sessions_insert on public.vision_board_daily_sessions
  for insert with check (auth.uid() = user_id);

create policy vision_board_daily_sessions_update on public.vision_board_daily_sessions
  for update using (auth.uid() = user_id) with check (auth.uid() = user_id);

create policy vision_board_daily_sessions_delete on public.vision_board_daily_sessions
  for delete using (auth.uid() = user_id);

create policy vision_board_daily_items_select on public.vision_board_daily_items
  for select using (auth.uid() = user_id);

create policy vision_board_daily_items_insert on public.vision_board_daily_items
  for insert with check (auth.uid() = user_id);

create policy vision_board_daily_items_update on public.vision_board_daily_items
  for update using (auth.uid() = user_id) with check (auth.uid() = user_id);

create policy vision_board_daily_items_delete on public.vision_board_daily_items
  for delete using (auth.uid() = user_id);
-- === END MIGRATION: 0117_vision_board_daily_game.sql ===

-- === BEGIN MIGRATION: 0118_checkins_upsert_rule.sql ===
-- Allow repeated life wheel check-ins on the same day to update existing entries
-- instead of failing the unique constraint.

drop rule if exists checkins_upsert on public.checkins;

create rule checkins_upsert as
on insert to public.checkins
where exists (
  select 1
  from public.checkins c
  where c.user_id = new.user_id
    and c.date = new.date
)
do instead
  update public.checkins
  set scores = new.scores
  where user_id = new.user_id
    and date = new.date
  returning *;
-- === END MIGRATION: 0118_checkins_upsert_rule.sql ===

-- === BEGIN MIGRATION: 0119_telemetry_events.sql ===
-- ========================================================
-- TELEMETRY EVENTS + PREFERENCES
-- Migration 0119: Opt-in telemetry for adaptation loops
-- ========================================================

CREATE TABLE IF NOT EXISTS public.telemetry_preferences (
  user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  telemetry_enabled BOOLEAN NOT NULL DEFAULT FALSE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS public.telemetry_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  event_type TEXT NOT NULL,
  metadata JSONB NOT NULL DEFAULT '{}'::jsonb,
  occurred_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_telemetry_preferences_user_id ON public.telemetry_preferences(user_id);
CREATE INDEX IF NOT EXISTS idx_telemetry_events_user_id ON public.telemetry_events(user_id);
CREATE INDEX IF NOT EXISTS idx_telemetry_events_type ON public.telemetry_events(event_type);
CREATE INDEX IF NOT EXISTS idx_telemetry_events_occurred_at ON public.telemetry_events(occurred_at DESC);

ALTER TABLE public.telemetry_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.telemetry_events ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view their own telemetry preferences" ON public.telemetry_preferences;
CREATE POLICY "Users can view their own telemetry preferences"
  ON public.telemetry_preferences FOR SELECT
  USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can insert their own telemetry preferences" ON public.telemetry_preferences;
CREATE POLICY "Users can insert their own telemetry preferences"
  ON public.telemetry_preferences FOR INSERT
  WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can update their own telemetry preferences" ON public.telemetry_preferences;
CREATE POLICY "Users can update their own telemetry preferences"
  ON public.telemetry_preferences FOR UPDATE
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can view their own telemetry events" ON public.telemetry_events;
CREATE POLICY "Users can view their own telemetry events"
  ON public.telemetry_events FOR SELECT
  USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can insert their own telemetry events" ON public.telemetry_events;
CREATE POLICY "Users can insert their own telemetry events"
  ON public.telemetry_events FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE OR REPLACE FUNCTION update_telemetry_preferences_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_telemetry_preferences_updated_at
  BEFORE UPDATE ON public.telemetry_preferences
  FOR EACH ROW
  EXECUTE FUNCTION update_telemetry_preferences_updated_at();

COMMENT ON TABLE public.telemetry_preferences IS 'Opt-in telemetry preferences for adaptation loops.';
COMMENT ON TABLE public.telemetry_events IS 'Minimal telemetry events used for adaptive recommendations.';
-- === END MIGRATION: 0119_telemetry_events.sql ===

-- === BEGIN MIGRATION: 0120_vision_board_image_tags.sql ===
-- Add category tagging for vision board images
create table if not exists public.vision_board_image_tags (
  image_id uuid not null references public.vision_images (id) on delete cascade,
  user_id uuid not null references auth.users (id) on delete cascade,
  category_key text not null,
  created_at timestamptz not null default now(),
  primary key (image_id, category_key)
);

create index if not exists idx_vision_board_image_tags_user_category
  on public.vision_board_image_tags (user_id, category_key);

create index if not exists idx_vision_board_image_tags_image
  on public.vision_board_image_tags (image_id);

alter table public.vision_board_image_tags enable row level security;

create policy vision_board_image_tags_select on public.vision_board_image_tags
  for select using (
    auth.uid() = user_id
    and exists (
      select 1 from public.vision_images i
      where i.id = image_id and i.user_id = auth.uid()
    )
  );

create policy vision_board_image_tags_insert on public.vision_board_image_tags
  for insert with check (
    auth.uid() = user_id
    and exists (
      select 1 from public.vision_images i
      where i.id = image_id and i.user_id = auth.uid()
    )
  );

create policy vision_board_image_tags_delete on public.vision_board_image_tags
  for delete using (
    auth.uid() = user_id
    and exists (
      select 1 from public.vision_images i
      where i.id = image_id and i.user_id = auth.uid()
    )
  );
-- === END MIGRATION: 0120_vision_board_image_tags.sql ===

-- === BEGIN MIGRATION: 0121_vision_board_image_tags_group.sql ===
-- Add category grouping for vision board image tags
alter table public.vision_board_image_tags
  add column if not exists category_group text not null default 'life_wheel';

update public.vision_board_image_tags
set category_group = 'life_wheel'
where category_group is null;

alter table public.vision_board_image_tags
  drop constraint if exists vision_board_image_tags_pkey;

alter table public.vision_board_image_tags
  add primary key (image_id, category_group, category_key);

drop index if exists idx_vision_board_image_tags_user_category;

create index if not exists idx_vision_board_image_tags_user_group
  on public.vision_board_image_tags (user_id, category_group, category_key);
-- === END MIGRATION: 0121_vision_board_image_tags_group.sql ===

-- === BEGIN MIGRATION: 0122_meditation_goals_tracking.sql ===
-- Migration: Meditation Goals Tracking System
-- Description: Create tables for meditation goal tracking with countdown, daily completions, and progress

-- =====================================================
-- 1. MEDITATION GOALS TABLE
-- =====================================================
CREATE TABLE IF NOT EXISTS meditation_goals (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  start_date DATE NOT NULL,
  target_days INTEGER NOT NULL DEFAULT 5,
  completed_days INTEGER NOT NULL DEFAULT 0,
  is_active BOOLEAN NOT NULL DEFAULT TRUE,
  reminder_time TIME,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- =====================================================
-- 2. DAILY COMPLETIONS TABLE
-- =====================================================
CREATE TABLE IF NOT EXISTS daily_completions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  goal_id UUID NOT NULL REFERENCES meditation_goals(id) ON DELETE CASCADE,
  completion_date DATE NOT NULL,
  duration_minutes INTEGER,
  activity_type VARCHAR(50) NOT NULL CHECK (activity_type IN ('meditation', 'breathing', 'body')),
  notes TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(goal_id, completion_date)
);

-- =====================================================
-- 3. USER SKILLS TABLE
-- =====================================================
CREATE TABLE IF NOT EXISTS user_skills (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  skill_name VARCHAR(100) NOT NULL,
  skill_level INTEGER NOT NULL DEFAULT 1,
  experience_points INTEGER NOT NULL DEFAULT 0,
  unlocked_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(user_id, skill_name)
);

-- =====================================================
-- 4. DAILY CHALLENGES TABLE
-- =====================================================
CREATE TABLE IF NOT EXISTS daily_challenges (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  challenge_date DATE NOT NULL,
  challenge_type VARCHAR(50) NOT NULL CHECK (challenge_type IN ('duration', 'frequency', 'variety')),
  description TEXT NOT NULL,
  target_value INTEGER NOT NULL,
  current_progress INTEGER NOT NULL DEFAULT 0,
  bonus_xp INTEGER NOT NULL DEFAULT 50,
  is_completed BOOLEAN NOT NULL DEFAULT FALSE,
  completed_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(user_id, challenge_date)
);

-- =====================================================
-- INDEXES FOR PERFORMANCE
-- =====================================================
CREATE INDEX IF NOT EXISTS idx_meditation_goals_user_id ON meditation_goals(user_id);
CREATE INDEX IF NOT EXISTS idx_meditation_goals_active ON meditation_goals(user_id, is_active);
CREATE INDEX IF NOT EXISTS idx_daily_completions_goal_id ON daily_completions(goal_id);
CREATE INDEX IF NOT EXISTS idx_daily_completions_date ON daily_completions(completion_date DESC);
CREATE INDEX IF NOT EXISTS idx_user_skills_user_id ON user_skills(user_id);
CREATE INDEX IF NOT EXISTS idx_daily_challenges_user_date ON daily_challenges(user_id, challenge_date);

-- =====================================================
-- ROW LEVEL SECURITY POLICIES
-- =====================================================

-- Enable RLS
ALTER TABLE meditation_goals ENABLE ROW LEVEL SECURITY;
ALTER TABLE daily_completions ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_skills ENABLE ROW LEVEL SECURITY;
ALTER TABLE daily_challenges ENABLE ROW LEVEL SECURITY;

-- Meditation Goals Policies
CREATE POLICY "Users can view their own meditation goals"
  ON meditation_goals FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own meditation goals"
  ON meditation_goals FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own meditation goals"
  ON meditation_goals FOR UPDATE
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete their own meditation goals"
  ON meditation_goals FOR DELETE
  USING (auth.uid() = user_id);

-- Daily Completions Policies
CREATE POLICY "Users can view their own daily completions"
  ON daily_completions FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM meditation_goals
      WHERE meditation_goals.id = daily_completions.goal_id
      AND meditation_goals.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can insert their own daily completions"
  ON daily_completions FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM meditation_goals
      WHERE meditation_goals.id = daily_completions.goal_id
      AND meditation_goals.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can update their own daily completions"
  ON daily_completions FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM meditation_goals
      WHERE meditation_goals.id = daily_completions.goal_id
      AND meditation_goals.user_id = auth.uid()
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM meditation_goals
      WHERE meditation_goals.id = daily_completions.goal_id
      AND meditation_goals.user_id = auth.uid()
    )
  );

-- User Skills Policies
CREATE POLICY "Users can view their own skills"
  ON user_skills FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own skills"
  ON user_skills FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own skills"
  ON user_skills FOR UPDATE
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Daily Challenges Policies
CREATE POLICY "Users can view their own daily challenges"
  ON daily_challenges FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own daily challenges"
  ON daily_challenges FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own daily challenges"
  ON daily_challenges FOR UPDATE
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- =====================================================
-- TRIGGERS FOR UPDATED_AT
-- =====================================================

-- Trigger for meditation_goals
CREATE TRIGGER update_meditation_goals_updated_at
  BEFORE UPDATE ON meditation_goals
  FOR EACH ROW
  EXECUTE FUNCTION update_gamification_updated_at();

-- =====================================================
-- COMMENTS FOR DOCUMENTATION
-- =====================================================

COMMENT ON TABLE meditation_goals IS 'User meditation goals with target days and progress tracking';
COMMENT ON TABLE daily_completions IS 'Daily meditation/breathing/body practice completions';
COMMENT ON TABLE user_skills IS 'User skills progression in different meditation and mindfulness areas';
COMMENT ON TABLE daily_challenges IS 'Daily challenges for users to complete for bonus XP';

COMMENT ON COLUMN meditation_goals.target_days IS 'Number of days to complete the goal';
COMMENT ON COLUMN meditation_goals.completed_days IS 'Number of days completed so far';
COMMENT ON COLUMN daily_completions.activity_type IS 'Type of activity: meditation, breathing, or body';
COMMENT ON COLUMN user_skills.skill_level IS 'Current level of the skill (1-10)';
COMMENT ON COLUMN daily_challenges.challenge_type IS 'Type of challenge: duration, frequency, or variety';
-- === END MIGRATION: 0122_meditation_goals_tracking.sql ===

-- === BEGIN MIGRATION: 0123_meditation_goals_functions.sql ===
-- Add helper function for incrementing meditation goal completed days

CREATE OR REPLACE FUNCTION increment_meditation_goal_days(goal_id UUID)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  UPDATE meditation_goals
  SET completed_days = completed_days + 1,
      updated_at = NOW()
  WHERE id = goal_id;
END;
$$;

-- Add comment
COMMENT ON FUNCTION increment_meditation_goal_days IS 'Increments the completed_days counter for a meditation goal';
-- === END MIGRATION: 0123_meditation_goals_functions.sql ===

-- === BEGIN MIGRATION: 0124_vision_board_storage_bucket.sql ===
-- ========================================================
-- VISION BOARD STORAGE BUCKET
-- Migration 0124: Create storage bucket for vision board images
-- ========================================================

-- Create the vision-board storage bucket
-- This bucket stores user-uploaded vision board images
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES (
  'vision-board',
  'vision-board',
  true,  -- Public bucket for easy image serving
  5242880,  -- 5MB file size limit
  ARRAY['image/png', 'image/jpeg', 'image/webp', 'image/gif']::text[]
)
ON CONFLICT (id) DO UPDATE SET
  public = EXCLUDED.public,
  file_size_limit = EXCLUDED.file_size_limit,
  allowed_mime_types = EXCLUDED.allowed_mime_types;

-- RLS Policies for vision-board bucket
-- ===========================================
-- IMPORTANT: Due to Supabase platform security, storage.objects policies
-- cannot be created/dropped via standard SQL migrations (requires supabase_storage_admin role).
-- 
-- You have two options:
--
-- OPTION 1 (Recommended): Create policies via Supabase Dashboard
-- ----------------------------------------------------------------
-- 1. Go to Supabase Dashboard > Storage > vision-board bucket
-- 2. Click "Policies" tab
-- 3. Add the following policies:
--
-- SELECT Policy:
--   Name: vision_board_select
--   Target roles: authenticated
--   USING: bucket_id = 'vision-board' AND ((storage.foldername(name))[1] = auth.uid()::text OR EXISTS (SELECT 1 FROM storage.buckets WHERE id = 'vision-board' AND public = true))
--
-- INSERT Policy:
--   Name: vision_board_insert
--   Target roles: authenticated
--   WITH CHECK: bucket_id = 'vision-board' AND (storage.foldername(name))[1] = auth.uid()::text
--
-- UPDATE Policy:
--   Name: vision_board_update
--   Target roles: authenticated
--   USING: bucket_id = 'vision-board' AND (storage.foldername(name))[1] = auth.uid()::text
--   WITH CHECK: bucket_id = 'vision-board' AND (storage.foldername(name))[1] = auth.uid()::text
--
-- DELETE Policy:
--   Name: vision_board_delete
--   Target roles: authenticated
--   USING: bucket_id = 'vision-board' AND (storage.foldername(name))[1] = auth.uid()::text
--
-- OPTION 2: Run via Supabase SQL Editor (with elevated permissions)
-- ------------------------------------------------------------------
-- Copy and paste the SQL below into the Supabase Dashboard SQL Editor:
--
/*
CREATE POLICY IF NOT EXISTS "vision_board_select" ON storage.objects
  FOR SELECT
  TO authenticated
  USING (
    bucket_id = 'vision-board'
    AND (
      (storage.foldername(name))[1] = auth.uid()::text
      OR EXISTS (
        SELECT 1 FROM storage.buckets
        WHERE id = 'vision-board' AND public = true
      )
    )
  );

CREATE POLICY IF NOT EXISTS "vision_board_insert" ON storage.objects
  FOR INSERT
  TO authenticated
  WITH CHECK (
    bucket_id = 'vision-board'
    AND (storage.foldername(name))[1] = auth.uid()::text
  );

CREATE POLICY IF NOT EXISTS "vision_board_update" ON storage.objects
  FOR UPDATE
  TO authenticated
  USING (
    bucket_id = 'vision-board'
    AND (storage.foldername(name))[1] = auth.uid()::text
  )
  WITH CHECK (
    bucket_id = 'vision-board'
    AND (storage.foldername(name))[1] = auth.uid()::text
  );

CREATE POLICY IF NOT EXISTS "vision_board_delete" ON storage.objects
  FOR DELETE
  TO authenticated
  USING (
    bucket_id = 'vision-board'
    AND (storage.foldername(name))[1] = auth.uid()::text
  );
*/
-- === END MIGRATION: 0124_vision_board_storage_bucket.sql ===

-- === BEGIN MIGRATION: 0125_annual_review_completed_at.sql ===
-- ========================================================
-- ANNUAL REVIEWS - Add completed_at field
-- Migration 0125: Track when users complete the annual review wizard
-- ========================================================

-- Add completed_at column to annual_reviews table
ALTER TABLE public.annual_reviews 
ADD COLUMN IF NOT EXISTS completed_at timestamptz;

-- Add comment for documentation
COMMENT ON COLUMN public.annual_reviews.completed_at IS 'Timestamp when the user completed the full annual review wizard (all 4 steps)';
-- === END MIGRATION: 0125_annual_review_completed_at.sql ===

-- === BEGIN MIGRATION: 0126_daily_spin_wheel.sql ===
-- ========================================================
-- DAILY SPIN WHEEL SYSTEM
-- Migration 0126: Daily reward spin mechanism
-- ========================================================

-- Daily spin state table
CREATE TABLE IF NOT EXISTS public.daily_spin_state (
  user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  last_spin_date DATE,
  spins_available INTEGER NOT NULL DEFAULT 0,
  total_spins_used INTEGER NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Spin history log
CREATE TABLE IF NOT EXISTS public.spin_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  prize_type TEXT NOT NULL CHECK (prize_type IN ('xp', 'points', 'streak_freeze', 'life', 'mystery')),
  prize_value INTEGER NOT NULL,
  prize_details JSONB DEFAULT '{}'::jsonb,
  spun_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_daily_spin_state_user_id ON public.daily_spin_state(user_id);
CREATE INDEX IF NOT EXISTS idx_daily_spin_state_last_spin ON public.daily_spin_state(last_spin_date);
CREATE INDEX IF NOT EXISTS idx_spin_history_user_id ON public.spin_history(user_id);
CREATE INDEX IF NOT EXISTS idx_spin_history_spun_at ON public.spin_history(spun_at DESC);

-- RLS Policies
ALTER TABLE public.daily_spin_state ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.spin_history ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view their own spin state" ON public.daily_spin_state;
CREATE POLICY "Users can view their own spin state"
  ON public.daily_spin_state FOR SELECT
  USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can insert their own spin state" ON public.daily_spin_state;
CREATE POLICY "Users can insert their own spin state"
  ON public.daily_spin_state FOR INSERT
  WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can update their own spin state" ON public.daily_spin_state;
CREATE POLICY "Users can update their own spin state"
  ON public.daily_spin_state FOR UPDATE
  USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can view their own spin history" ON public.spin_history;
CREATE POLICY "Users can view their own spin history"
  ON public.spin_history FOR SELECT
  USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can insert their own spin history" ON public.spin_history;
CREATE POLICY "Users can insert their own spin history"
  ON public.spin_history FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Add trigger for updated_at
CREATE TRIGGER update_daily_spin_state_updated_at
  BEFORE UPDATE ON public.daily_spin_state
  FOR EACH ROW
  EXECUTE FUNCTION update_gamification_updated_at();

-- Add new spin-based achievements
INSERT INTO public.achievements (achievement_key, name, description, icon, xp_reward, tier, category, requirement_type, requirement_value)
VALUES
  ('lucky_spinner', 'Lucky Spinner', 'Use the daily spin 7 times', '🎰', 100, 'bronze', 'general', 'spins_used', 7),
  ('spin_master', 'Spin Master', 'Use the daily spin 30 times', '🎯', 300, 'silver', 'general', 'spins_used', 30),
  ('jackpot', 'Jackpot!', 'Win the mystery prize from daily spin', '🎁', 200, 'gold', 'general', 'mystery_wins', 1)
ON CONFLICT (achievement_key) DO NOTHING;

-- Comments
COMMENT ON TABLE public.daily_spin_state IS 'Tracks daily spin availability and usage per user';
COMMENT ON TABLE public.spin_history IS 'Logs all spin results for analytics and achievement tracking';
-- === END MIGRATION: 0126_daily_spin_wheel.sql ===

-- === BEGIN MIGRATION: 0127_power_ups_store.sql ===
-- ========================================================
-- POWER-UPS STORE SYSTEM
-- Migration 0127: Consolidated power-ups schema + Phase 2 catalog
-- ========================================================

-- Add missing columns to achievements table if they don't exist
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                 WHERE table_schema = 'public'
                 AND table_name = 'achievements'
                 AND column_name = 'points_reward') THEN
    ALTER TABLE public.achievements ADD COLUMN points_reward INT NOT NULL DEFAULT 0;
  END IF;

  IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                 WHERE table_schema = 'public'
                 AND table_name = 'achievements'
                 AND column_name = 'sort_order') THEN
    ALTER TABLE public.achievements ADD COLUMN sort_order INT NOT NULL DEFAULT 0;
  END IF;
END $$;

-- Power-ups catalog table
CREATE TABLE IF NOT EXISTS public.power_ups (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  power_up_key TEXT UNIQUE NOT NULL,
  name TEXT NOT NULL,
  description TEXT NOT NULL,
  icon TEXT NOT NULL,
  cost_points INTEGER NOT NULL,
  effect_type TEXT NOT NULL, -- 'xp_multiplier', 'streak_freeze', 'instant_xp', 'extra_life', 'spin_token', 'mystery'
  effect_value NUMERIC NOT NULL,
  duration_minutes INTEGER, -- NULL for instant/permanent effects
  type TEXT NOT NULL DEFAULT 'temporary' CHECK (type IN ('temporary', 'permanent')),
  category TEXT NOT NULL DEFAULT 'boosts' CHECK (category IN ('boosts', 'protection', 'upgrades')),
  is_active BOOLEAN NOT NULL DEFAULT true,
  sort_order INTEGER NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- User power-ups (purchases and active items)
CREATE TABLE IF NOT EXISTS public.user_power_ups (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  power_up_id UUID NOT NULL REFERENCES public.power_ups(id) ON DELETE CASCADE,
  purchased_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  activated_at TIMESTAMPTZ,
  expires_at TIMESTAMPTZ,
  is_active BOOLEAN NOT NULL DEFAULT false,
  is_consumed BOOLEAN NOT NULL DEFAULT false,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Power-up transaction log
CREATE TABLE IF NOT EXISTS public.power_up_transactions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  power_up_id UUID NOT NULL REFERENCES public.power_ups(id) ON DELETE CASCADE,
  action TEXT NOT NULL, -- 'purchase', 'activate', 'expire', 'consume'
  points_spent INTEGER NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add type and category columns to power_ups table if they don't exist
DO $$
BEGIN
  -- Add type column (temporary vs permanent)
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                 WHERE table_schema = 'public'
                 AND table_name = 'power_ups'
                 AND column_name = 'type') THEN
    ALTER TABLE public.power_ups ADD COLUMN type TEXT NOT NULL DEFAULT 'temporary'
      CHECK (type IN ('temporary', 'permanent'));
  END IF;

  -- Add category column (boosts, protection, upgrades)
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                 WHERE table_schema = 'public'
                 AND table_name = 'power_ups'
                 AND column_name = 'category') THEN
    ALTER TABLE public.power_ups ADD COLUMN category TEXT NOT NULL DEFAULT 'boosts'
      CHECK (category IN ('boosts', 'protection', 'upgrades'));
  END IF;
END $$;

-- Update effect_type CHECK constraint to include Phase 2 effect types
-- Note: PostgreSQL requires dropping and recreating constraints
DO $$
BEGIN
  -- Drop old constraint if it exists
  IF EXISTS (SELECT 1 FROM information_schema.table_constraints 
             WHERE constraint_name = 'power_ups_effect_type_check' 
             AND table_name = 'power_ups') THEN
    ALTER TABLE public.power_ups DROP CONSTRAINT power_ups_effect_type_check;
  END IF;
  
  -- Add new constraint with Phase 2 effect types
  ALTER TABLE public.power_ups ADD CONSTRAINT power_ups_effect_type_check 
    CHECK (effect_type IN (
      'xp_multiplier', 
      'streak_freeze', 
      'instant_xp', 
      'extra_life', 
      'spin_token', 
      'mystery',
      'max_lives_increase',
      'freeze_bank_increase',
      'daily_spin_increase'
    ));
END $$;

-- Add indexes for new columns
CREATE INDEX IF NOT EXISTS idx_power_ups_type ON public.power_ups(type);
CREATE INDEX IF NOT EXISTS idx_power_ups_category ON public.power_ups(category);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_power_ups_key ON public.power_ups(power_up_key);
CREATE INDEX IF NOT EXISTS idx_power_ups_active ON public.power_ups(is_active);
CREATE INDEX IF NOT EXISTS idx_user_power_ups_user_id ON public.user_power_ups(user_id);
CREATE INDEX IF NOT EXISTS idx_user_power_ups_active ON public.user_power_ups(user_id, is_active) WHERE is_active = true;
CREATE INDEX IF NOT EXISTS idx_user_power_ups_expires ON public.user_power_ups(expires_at) WHERE expires_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_power_up_transactions_user_id ON public.power_up_transactions(user_id);
CREATE INDEX IF NOT EXISTS idx_power_up_transactions_created_at ON public.power_up_transactions(created_at DESC);

-- RLS Policies
ALTER TABLE public.power_ups ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_power_ups ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.power_up_transactions ENABLE ROW LEVEL SECURITY;

-- Power-ups: Anyone can view active power-ups
CREATE POLICY "Anyone can view active power-ups"
  ON public.power_ups FOR SELECT
  USING (is_active = true);

-- User power-ups: Users can view their own
CREATE POLICY "Users can view their own power-ups"
  ON public.user_power_ups FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own power-ups"
  ON public.user_power_ups FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own power-ups"
  ON public.user_power_ups FOR UPDATE
  USING (auth.uid() = user_id);

-- Transactions: Users can view their own
CREATE POLICY "Users can view their own transactions"
  ON public.power_up_transactions FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own transactions"
  ON public.power_up_transactions FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Clear existing power-ups and insert Phase 2 catalog
-- This ensures we have the correct power-ups for Phase 2
TRUNCATE TABLE public.power_ups CASCADE;

-- Insert Phase 2 Power-ups Catalog
INSERT INTO public.power_ups (power_up_key, name, description, icon, type, cost_points, duration_minutes, effect_type, effect_value, category, sort_order)
VALUES
  -- ===== TEMPORARY POWER-UPS: BOOSTS =====
  ('xp_boost_1h_2x', '2x XP Boost (1 hour)', 'Double all XP gains for 1 hour', '⚡', 'temporary', 50, 60, 'xp_multiplier', 2, 'boosts', 1),
  ('xp_boost_1h_5x', '5x XP Boost (1 hour)', 'Quintuple all XP gains for 1 hour', '🚀', 'temporary', 200, 60, 'xp_multiplier', 5, 'boosts', 2),
  ('perfect_day', 'Perfect Day Guarantee', 'Ensures all habits count as completed today', '✨', 'temporary', 300, NULL, 'instant_xp', 100, 'boosts', 3),
  
  -- ===== TEMPORARY POWER-UPS: PROTECTION =====
  ('streak_freeze_1', 'Streak Freeze (1 use)', 'Protects your streak for one missed day', '🛡️', 'temporary', 100, NULL, 'streak_freeze', 1, 'protection', 10),
  ('extra_life_1', 'Extra Life (1 heart)', 'Adds one life to your total', '❤️', 'temporary', 75, NULL, 'extra_life', 1, 'protection', 11),
  
  -- ===== PERMANENT UPGRADES =====
  ('max_lives_plus_1', 'Max Lives +1', 'Permanently increase maximum lives by 1', '💪', 'permanent', 500, NULL, 'max_lives_increase', 1, 'upgrades', 20),
  ('freeze_bank_plus_1', 'Streak Freeze Bank +1', 'Permanently increase freeze capacity by 1', '🏦', 'permanent', 750, NULL, 'freeze_bank_increase', 1, 'upgrades', 21),
  ('daily_spin_plus_1', 'Daily Spin +1', 'Add one extra daily spin permanently', '🎰', 'permanent', 1000, NULL, 'daily_spin_increase', 1, 'upgrades', 22)
ON CONFLICT (power_up_key) DO UPDATE SET
  name = EXCLUDED.name,
  description = EXCLUDED.description,
  icon = EXCLUDED.icon,
  type = EXCLUDED.type,
  cost_points = EXCLUDED.cost_points,
  duration_minutes = EXCLUDED.duration_minutes,
  effect_type = EXCLUDED.effect_type,
  effect_value = EXCLUDED.effect_value,
  category = EXCLUDED.category,
  sort_order = EXCLUDED.sort_order;

-- Update Phase 2 achievements for power-ups
INSERT INTO public.achievements (achievement_key, name, description, icon, tier, category, xp_reward, requirement_type, requirement_value, points_reward, sort_order)
VALUES
  ('power_shopper', 'Power Shopper', 'Purchase 10 power-ups from the store', '🛍️', 'bronze', 'general', 150, 'powerups_purchased', 10, 75, 70),
  ('power_user_5x', 'Power User', 'Activate a 5X XP boost', '🚀', 'silver', 'general', 200, 'triple_boost_used', 1, 100, 71),
  ('permanent_upgrade', 'Permanent Upgrade', 'Purchase your first permanent upgrade', '💎', 'gold', 'general', 300, 'powerups_purchased', 1, 150, 72)
ON CONFLICT (achievement_key) DO UPDATE SET
  name = EXCLUDED.name,
  description = EXCLUDED.description,
  icon = EXCLUDED.icon,
  tier = EXCLUDED.tier,
  category = EXCLUDED.category,
  xp_reward = EXCLUDED.xp_reward,
  requirement_type = EXCLUDED.requirement_type,
  requirement_value = EXCLUDED.requirement_value,
  points_reward = EXCLUDED.points_reward,
  sort_order = EXCLUDED.sort_order;

-- Add column to gamification_profiles for freeze bank capacity if not exists
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                 WHERE table_schema = 'public' 
                 AND table_name = 'gamification_profiles' 
                 AND column_name = 'freeze_bank_capacity') THEN
    ALTER TABLE public.gamification_profiles 
      ADD COLUMN freeze_bank_capacity INT NOT NULL DEFAULT 3;
  END IF;
END $$;

-- Comments for documentation
COMMENT ON TABLE public.power_ups IS 'Catalog of available power-ups in the store';
COMMENT ON TABLE public.user_power_ups IS 'User purchases and active power-ups';
COMMENT ON TABLE public.power_up_transactions IS 'Transaction log for all power-up purchases and activations';
COMMENT ON COLUMN public.power_ups.effect_type IS 'Type of effect: xp_multiplier, streak_freeze, instant_xp, extra_life, spin_token, mystery';
COMMENT ON COLUMN public.power_ups.duration_minutes IS 'Duration in minutes for timed effects, NULL for instant/permanent';
COMMENT ON COLUMN public.power_ups.type IS 'temporary: Time-limited or consumable, permanent: Lasting upgrades';
COMMENT ON COLUMN public.power_ups.category IS 'boosts: XP multipliers and bonuses, protection: Lives and freezes, upgrades: Permanent improvements';
COMMENT ON COLUMN public.gamification_profiles.freeze_bank_capacity IS 'Maximum number of streak freezes user can hold';

-- Create function to apply permanent upgrade
CREATE OR REPLACE FUNCTION apply_permanent_upgrade(
  p_user_id UUID,
  p_effect_type TEXT,
  p_effect_value INT
) RETURNS VOID AS $$
BEGIN
  CASE p_effect_type
    WHEN 'max_lives_increase' THEN
      UPDATE public.gamification_profiles
      SET max_lives = max_lives + p_effect_value
      WHERE user_id = p_user_id;
      
    WHEN 'freeze_bank_increase' THEN
      UPDATE public.gamification_profiles
      SET freeze_bank_capacity = freeze_bank_capacity + p_effect_value
      WHERE user_id = p_user_id;
      
    WHEN 'daily_spin_increase' THEN
      -- Add bonus spin to daily spin state
      INSERT INTO public.daily_spin_state (user_id, spins_available, total_spins_used)
      VALUES (p_user_id, 1, 0)
      ON CONFLICT (user_id) DO UPDATE
      SET spins_available = daily_spin_state.spins_available + p_effect_value;
      
    ELSE
      RAISE EXCEPTION 'Unknown permanent effect type: %', p_effect_type;
  END CASE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION apply_permanent_upgrade IS 'Applies permanent power-up upgrades to user profile';
-- === END MIGRATION: 0127_power_ups_store.sql ===

-- === BEGIN MIGRATION: 0128_optimize_push_notifications.sql ===
-- ========================================================
-- PUSH NOTIFICATIONS OPTIMIZATION
-- Migration 0128: Indexes and functions for efficient reminder lookups
-- Purpose: Scale push notifications from 0 to 1,000+ users
-- ========================================================

-- Index for finding active habits quickly
-- This index helps filter habits by user and archived status efficiently
CREATE INDEX IF NOT EXISTS idx_habits_v2_active_user 
ON habits_v2(user_id, archived) 
WHERE archived = false;

-- Index for finding habits with reminders
-- Speeds up joins between habits and their reminder configurations
CREATE INDEX IF NOT EXISTS idx_habit_reminders_habit_id 
ON habit_reminders(habit_id);

-- Index for push subscriptions by user
-- Enables fast lookup of user subscriptions
CREATE INDEX IF NOT EXISTS idx_push_subscriptions_user 
ON push_subscriptions(user_id);

-- Index for reminder state lookups
-- Helps quickly find last reminder sent time for idempotency checks
CREATE INDEX IF NOT EXISTS idx_habit_reminder_state_habit 
ON habit_reminder_state(habit_id, last_reminder_sent_at);

-- Index for habit prefs
-- Speeds up filtering habits by enabled reminder preference
CREATE INDEX IF NOT EXISTS idx_habit_reminder_prefs_habit 
ON habit_reminder_prefs(habit_id) 
WHERE enabled = true;

-- Optimized view for finding eligible users
-- This view pre-filters users who have active habits with configured reminders
-- Use this to reduce the number of users checked in the CRON job
CREATE OR REPLACE VIEW v_users_with_active_reminders AS
SELECT DISTINCT h.user_id
FROM habits_v2 h
INNER JOIN habit_reminders hr ON hr.habit_id = h.id
WHERE h.archived = false;

COMMENT ON VIEW v_users_with_active_reminders IS 
'Materialized view candidate: Users who have active habits with configured reminders. Use this to filter users before checking reminder windows.';

-- Database function to get users with active reminders
-- This function is called by the Edge Function to efficiently get eligible users
-- Returns a list of user IDs who have at least one active habit with reminders configured
CREATE OR REPLACE FUNCTION get_users_with_active_reminders()
RETURNS TABLE(user_id UUID) AS $$
BEGIN
  RETURN QUERY
  SELECT DISTINCT h.user_id
  FROM habits_v2 h
  INNER JOIN habit_reminders hr ON hr.habit_id = h.id
  WHERE h.archived = false;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION get_users_with_active_reminders() IS 
'Returns user IDs who have active (non-archived) habits with reminder configurations. Used by CRON to filter users before checking time windows.';
-- === END MIGRATION: 0128_optimize_push_notifications.sql ===

-- === BEGIN MIGRATION: 0129_actions_feature.sql ===
-- Migration: Actions Feature (Phase 0)
-- Description: Create tables for Actions and Projects two-tier task management system
-- Reference: ACTIONS_FEATURE_DEV_PLAN.md

-- =====================================================
-- 1. PROJECTS TABLE (Create first due to FK reference from actions)
-- =====================================================
CREATE TABLE IF NOT EXISTS projects (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  description TEXT,
  status TEXT NOT NULL DEFAULT 'planning' CHECK (status IN ('planning', 'active', 'on_hold', 'completed', 'archived')),
  priority TEXT CHECK (priority IN ('low', 'medium', 'high', 'urgent')),
  goal_id UUID REFERENCES goals(id) ON DELETE SET NULL,
  start_date DATE,
  target_date DATE,
  completed_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  archived_at TIMESTAMPTZ,
  color TEXT DEFAULT '#6366f1',
  icon TEXT DEFAULT '📋',
  order_index INTEGER NOT NULL DEFAULT 0,
  xp_reward INTEGER DEFAULT 100
);

-- =====================================================
-- 2. ACTIONS TABLE (Simple 3-day rolling tasks)
-- =====================================================
CREATE TABLE IF NOT EXISTS actions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  category TEXT NOT NULL CHECK (category IN ('must_do', 'nice_to_do', 'project')),
  completed BOOLEAN NOT NULL DEFAULT FALSE,
  completed_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  expires_at TIMESTAMPTZ NOT NULL DEFAULT (NOW() + INTERVAL '3 days'),
  migrated_to_project_id UUID REFERENCES projects(id) ON DELETE SET NULL,
  order_index INTEGER NOT NULL DEFAULT 0,
  notes TEXT,
  xp_awarded INTEGER DEFAULT 0
);

-- =====================================================
-- 3. PROJECT TASKS TABLE (Subtasks within projects)
-- =====================================================
CREATE TABLE IF NOT EXISTS project_tasks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  description TEXT,
  status TEXT NOT NULL DEFAULT 'todo' CHECK (status IN ('todo', 'in_progress', 'blocked', 'done')),
  parent_task_id UUID REFERENCES project_tasks(id) ON DELETE CASCADE,
  depends_on_task_id UUID REFERENCES project_tasks(id) ON DELETE SET NULL,
  completed BOOLEAN NOT NULL DEFAULT FALSE,
  completed_at TIMESTAMPTZ,
  due_date DATE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  order_index INTEGER NOT NULL DEFAULT 0,
  estimated_hours NUMERIC(5,2),
  actual_hours NUMERIC(5,2)
);

-- =====================================================
-- INDEXES FOR PERFORMANCE
-- =====================================================

-- Actions indexes
CREATE INDEX IF NOT EXISTS idx_actions_user_id ON actions(user_id);
CREATE INDEX IF NOT EXISTS idx_actions_user_category ON actions(user_id, category);
CREATE INDEX IF NOT EXISTS idx_actions_expires_at ON actions(expires_at);
CREATE INDEX IF NOT EXISTS idx_actions_completed ON actions(user_id, completed);

-- Projects indexes
CREATE INDEX IF NOT EXISTS idx_projects_user_id ON projects(user_id);
CREATE INDEX IF NOT EXISTS idx_projects_user_status ON projects(user_id, status);
CREATE INDEX IF NOT EXISTS idx_projects_goal_id ON projects(goal_id);

-- Project tasks indexes
CREATE INDEX IF NOT EXISTS idx_project_tasks_project_id ON project_tasks(project_id);
CREATE INDEX IF NOT EXISTS idx_project_tasks_user_id ON project_tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_project_tasks_status ON project_tasks(project_id, status);
CREATE INDEX IF NOT EXISTS idx_project_tasks_parent ON project_tasks(parent_task_id);

-- =====================================================
-- ROW LEVEL SECURITY POLICIES
-- =====================================================

-- Enable RLS
ALTER TABLE actions ENABLE ROW LEVEL SECURITY;
ALTER TABLE projects ENABLE ROW LEVEL SECURITY;
ALTER TABLE project_tasks ENABLE ROW LEVEL SECURITY;

-- Actions Policies
CREATE POLICY "Users can view their own actions"
  ON actions FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can create their own actions"
  ON actions FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own actions"
  ON actions FOR UPDATE
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete their own actions"
  ON actions FOR DELETE
  USING (auth.uid() = user_id);

-- Projects Policies
CREATE POLICY "Users can view their own projects"
  ON projects FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can create their own projects"
  ON projects FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own projects"
  ON projects FOR UPDATE
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete their own projects"
  ON projects FOR DELETE
  USING (auth.uid() = user_id);

-- Project Tasks Policies
CREATE POLICY "Users can view tasks for their projects"
  ON project_tasks FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can create tasks for their projects"
  ON project_tasks FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update tasks for their projects"
  ON project_tasks FOR UPDATE
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete tasks for their projects"
  ON project_tasks FOR DELETE
  USING (auth.uid() = user_id);

-- =====================================================
-- TRIGGERS FOR UPDATED_AT
-- =====================================================

-- Function to update updated_at timestamp (reuse if exists)
CREATE OR REPLACE FUNCTION update_actions_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Triggers for projects
CREATE TRIGGER update_projects_updated_at
  BEFORE UPDATE ON projects
  FOR EACH ROW
  EXECUTE FUNCTION update_actions_updated_at();

-- Triggers for project_tasks
CREATE TRIGGER update_project_tasks_updated_at
  BEFORE UPDATE ON project_tasks
  FOR EACH ROW
  EXECUTE FUNCTION update_actions_updated_at();

-- =====================================================
-- COMMENTS FOR DOCUMENTATION
-- =====================================================

COMMENT ON TABLE actions IS 'Simple 3-day rolling todo list items with categories: must_do, nice_to_do, project';
COMMENT ON TABLE projects IS 'Multi-step project initiatives that can link to goals';
COMMENT ON TABLE project_tasks IS 'Subtasks within projects with dependency support';

COMMENT ON COLUMN actions.category IS 'Task priority: must_do (stays forever), nice_to_do (auto-delete 3 days), project (auto-migrate 3 days)';
COMMENT ON COLUMN actions.expires_at IS 'Per-task expiration timestamp, 3 days from creation';
COMMENT ON COLUMN actions.migrated_to_project_id IS 'Reference to project if this action was migrated';
COMMENT ON COLUMN projects.status IS 'Project lifecycle: planning, active, on_hold, completed, archived';
COMMENT ON COLUMN projects.goal_id IS 'Optional link to a life goal';
COMMENT ON COLUMN project_tasks.depends_on_task_id IS 'Optional dependency - task cannot start until dependency is done';
-- === END MIGRATION: 0129_actions_feature.sql ===

-- === BEGIN MIGRATION: 0130_add_zen_tokens.sql ===
-- Migration: add zen token balance to gamification profiles
-- Description: persist zen tokens earned from meditation and breathing sessions

ALTER TABLE public.gamification_profiles
  ADD COLUMN IF NOT EXISTS zen_tokens INT NOT NULL DEFAULT 0;

COMMENT ON COLUMN public.gamification_profiles.zen_tokens IS 'Zen token balance earned primarily from meditation activities';
-- === END MIGRATION: 0130_add_zen_tokens.sql ===

-- === BEGIN MIGRATION: 0131_add_project_id_to_actions.sql ===
-- Add project_id column to actions table for project tagging
-- This is different from migrated_to_project_id which is for archiving
ALTER TABLE actions
ADD COLUMN IF NOT EXISTS project_id UUID REFERENCES projects(id) ON DELETE SET NULL;

-- Create index for efficient querying
CREATE INDEX IF NOT EXISTS idx_actions_project_id ON actions(project_id) WHERE project_id IS NOT NULL;

-- Add comment to clarify the difference
COMMENT ON COLUMN actions.project_id IS 'Optional project tag to associate an action with a project (different from migrated_to_project_id which is for archiving)';
COMMENT ON COLUMN actions.migrated_to_project_id IS 'Project ID when action is archived/moved to a project (makes action read-only)';
-- === END MIGRATION: 0131_add_project_id_to_actions.sql ===

-- === BEGIN MIGRATION: 0132_personality_test.sql ===
-- Personality test schema (profiles extensions + test history + recommendations)

ALTER TABLE public.profiles
  ADD COLUMN IF NOT EXISTS personality_traits jsonb,
  ADD COLUMN IF NOT EXISTS personality_axes jsonb,
  ADD COLUMN IF NOT EXISTS personality_profile_type text,
  ADD COLUMN IF NOT EXISTS personality_summary text,
  ADD COLUMN IF NOT EXISTS personality_last_tested_at timestamptz;

CREATE TABLE IF NOT EXISTS public.personality_tests (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  taken_at timestamptz DEFAULT now(),
  traits jsonb NOT NULL,
  axes jsonb NOT NULL,
  answers jsonb,
  version text NOT NULL DEFAULT 'v1'
);

CREATE INDEX IF NOT EXISTS idx_personality_tests_user_id
  ON public.personality_tests (user_id);
CREATE INDEX IF NOT EXISTS idx_personality_tests_user_taken_at
  ON public.personality_tests (user_id, taken_at DESC);

CREATE TABLE IF NOT EXISTS public.personality_questions (
  id text PRIMARY KEY,
  text text NOT NULL,
  trait_key text NOT NULL,
  axis_type text NOT NULL CHECK (axis_type IN ('big5', 'custom')),
  reverse_scored boolean NOT NULL DEFAULT false,
  order_index integer
);

CREATE TABLE IF NOT EXISTS public.personality_recommendations (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  trait_key text NOT NULL,
  min_value numeric,
  max_value numeric,
  label text NOT NULL,
  description text NOT NULL,
  action_link jsonb,
  priority integer DEFAULT 0
);

ALTER TABLE public.personality_tests ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.personality_questions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.personality_recommendations ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "personality_tests_owner_all" ON public.personality_tests;
CREATE POLICY "personality_tests_owner_all"
  ON public.personality_tests
  FOR ALL
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "personality_questions_read" ON public.personality_questions;
CREATE POLICY "personality_questions_read"
  ON public.personality_questions
  FOR SELECT
  USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "personality_recommendations_read" ON public.personality_recommendations;
CREATE POLICY "personality_recommendations_read"
  ON public.personality_recommendations
  FOR SELECT
  USING (auth.role() = 'authenticated');
-- === END MIGRATION: 0132_personality_test.sql ===
