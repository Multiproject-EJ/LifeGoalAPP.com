-- Auto-generated manual bundle
-- Source: supabase/migrations/*.sql
-- Do not edit this file by hand.
-- Last generated: 2025-12-10T12:50:04.879Z

-- === BEGIN MIGRATION: 0001_habits_core.sql ===
-- ========================================================
-- HABITS MODULE - CORE SCHEMA
-- Migration 0001: Habits, Logs, Reminders, Profiles, Streaks
-- ========================================================

-- PROFILES TABLE (for user timezone and display name)
create table if not exists public.profiles (
  user_id uuid primary key references auth.users(id) on delete cascade,
  created_at timestamptz default now(),
  display_name text,
  tz text default 'UTC'
);

-- HABIT TYPE ENUM
do $$ begin
  create type habit_type as enum ('boolean','quantity','duration');
exception
  when duplicate_object then null;
end $$;

-- HABITS TABLE (enhanced version with new fields)
-- Note: We'll check if columns exist before adding to avoid conflicts with existing habits table
do $$
begin
  -- Check if we need to extend the existing habits table or create a new one
  if not exists (select 1 from information_schema.tables where table_schema = 'public' and table_name = 'habits_v2') then
    create table public.habits_v2 (
      id uuid primary key default gen_random_uuid(),
      user_id uuid not null references auth.users(id) on delete cascade,
      title text not null,
      emoji text,
      type habit_type not null default 'boolean',
      target_num numeric,
      target_unit text,
      schedule jsonb not null,
      allow_skip boolean default true,
      start_date date default current_date,
      archived boolean default false,
      created_at timestamptz default now(),
      autoprog jsonb -- For auto-progression config
    );
  end if;
end $$;

-- HABIT REMINDERS TABLE
create table if not exists public.habit_reminders (
  id uuid primary key default gen_random_uuid(),
  habit_id uuid not null,
  local_time time not null,
  days int[] default null,
  geo jsonb,
  created_at timestamptz default now()
);

-- Add foreign key constraint with proper check
do $$
begin
  if exists (select 1 from information_schema.tables where table_schema = 'public' and table_name = 'habits_v2') then
    if not exists (
      select 1 from information_schema.table_constraints 
      where constraint_name = 'habit_reminders_habit_id_fkey_v2' 
      and table_name = 'habit_reminders'
    ) then
      alter table public.habit_reminders add constraint habit_reminders_habit_id_fkey_v2 
        foreign key (habit_id) references public.habits_v2(id) on delete cascade;
    end if;
  end if;
end $$;

-- HABIT LOGS TABLE (enhanced version)
do $$
begin
  if not exists (select 1 from information_schema.tables where table_schema = 'public' and table_name = 'habit_logs_v2') then
    create table public.habit_logs_v2 (
      id uuid primary key default gen_random_uuid(),
      habit_id uuid not null references public.habits_v2(id) on delete cascade,
      user_id uuid not null references auth.users(id) on delete cascade,
      ts timestamptz not null default now(),
      date date not null,
      value numeric,
      done boolean not null default true,
      note text,
      mood int check (mood between 1 and 5)
    );

    create index idx_habit_logs_v2_habit_date on public.habit_logs_v2(habit_id, date);
    create index idx_habit_logs_v2_user_date on public.habit_logs_v2(user_id, date);
  end if;
end $$;

do $$
begin
  if exists (
    select 1 from information_schema.columns
    where table_schema = 'public'
      and table_name = 'habit_logs_v2'
      and column_name = 'date'
  ) then
    begin
      execute 'alter table public.habit_logs_v2 alter column date drop expression';
    exception
      when others then null;
    end;

    alter table public.habit_logs_v2
      alter column date set default ((timezone('UTC', now()))::date);
  end if;
end $$;

create or replace function public.set_habit_logs_v2_date()
returns trigger language plpgsql as $$
begin
  if new.ts is null then
    new.ts := now();
  end if;
  new.date := (timezone('UTC', new.ts)::date);
  return new;
end;
$$;

drop trigger if exists habit_logs_v2_set_date on public.habit_logs_v2;
create trigger habit_logs_v2_set_date
before insert or update on public.habit_logs_v2
for each row execute function public.set_habit_logs_v2_date();

-- STREAKS VIEW
create or replace view public.v_habit_streaks as
with daily as (
  select h.id habit_id, l.date, bool_or(l.done) as done
  from habits_v2 h
  left join habit_logs_v2 l on l.habit_id = h.id
  group by h.id, l.date
), gaps as (
  select habit_id, date, date - (row_number() over (partition by habit_id order by date))::int grp
  from daily where done is true
)
select habit_id,
       coalesce( (select count(*) from gaps g2
                  where g2.habit_id=g.habit_id
                    and g2.grp=(select max(grp) from gaps g3 where g3.habit_id=g.habit_id)), 0)::int as current_streak,
       coalesce( (select max(cnt) from (
                   select count(*) cnt from gaps g4 where g4.habit_id=g.habit_id group by grp
                 ) s), 0)::int as best_streak
from gaps g
group by habit_id;

-- RLS POLICIES
alter table public.habits_v2 enable row level security;
alter table public.habit_logs_v2 enable row level security;
alter table public.habit_reminders enable row level security;
alter table public.profiles enable row level security;

-- Profiles policies
drop policy if exists "own profiles" on public.profiles;
create policy "own profiles" on public.profiles
  for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

-- Habits policies
drop policy if exists "own habits v2" on public.habits_v2;
create policy "own habits v2" on public.habits_v2
  for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

-- Logs policies
drop policy if exists "own logs v2" on public.habit_logs_v2;
create policy "own logs v2" on public.habit_logs_v2
  for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

-- Reminders policies
drop policy if exists "own reminders v2" on public.habit_reminders;
create policy "own reminders v2" on public.habit_reminders
  for all using (
    exists (select 1 from habits_v2 where id = habit_id and user_id = auth.uid())
  )
  with check (
    exists (select 1 from habits_v2 where id = habit_id and user_id = auth.uid())
  );
-- === END MIGRATION: 0001_habits_core.sql ===

-- === BEGIN MIGRATION: 0002_push.sql ===
-- ========================================================
-- HABITS MODULE - WEB PUSH NOTIFICATIONS
-- Migration 0002: Push Subscriptions
-- ========================================================

-- PUSH SUBSCRIPTIONS TABLE
create table if not exists public.push_subscriptions (
  user_id uuid not null references auth.users(id) on delete cascade,
  endpoint text primary key,
  p256dh text not null,
  auth text not null,
  created_at timestamptz default now()
);

-- RLS
alter table public.push_subscriptions enable row level security;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'push_subscriptions'
      and policyname = 'own push'
  ) then
    execute $pol$
      create policy "own push" on public.push_subscriptions
        for all using (auth.uid() = user_id) with check (auth.uid() = user_id);
    $pol$;
  end if;
end$$ language plpgsql;
-- === END MIGRATION: 0002_push.sql ===

-- === BEGIN MIGRATION: 0003_challenges_autoprog.sql ===
-- ========================================================
-- HABITS MODULE - CHALLENGES & AUTO-PROGRESSION
-- Migration 0003: Challenges, Leaderboard, Auto-Progression
-- ========================================================

-- CHALLENGES TABLE
create table if not exists public.habit_challenges (
  id uuid primary key default gen_random_uuid(),
  owner_id uuid not null references auth.users(id) on delete cascade,
  title text not null,
  description text,
  start_date date not null,
  end_date date not null,
  scoring text not null default 'count', -- 'count' = #days done; 'sum' = sum(value)
  created_at timestamptz default now()
);

-- CHALLENGE MEMBERS TABLE
create table if not exists public.habit_challenge_members (
  id uuid primary key default gen_random_uuid(),
  challenge_id uuid not null references public.habit_challenges(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  habit_id uuid, -- optional link to a specific habit (references habits_v2)
  joined_at timestamptz default now(),
  unique (challenge_id, user_id)
);

-- Add foreign key for habit_id if habits_v2 exists
do $$
begin
  if exists (select 1 from information_schema.tables where table_schema = 'public' and table_name = 'habits_v2') then
    if not exists (
      select 1 from information_schema.table_constraints 
      where constraint_name = 'habit_challenge_members_habit_id_fkey' 
      and table_name = 'habit_challenge_members'
    ) then
      alter table public.habit_challenge_members add constraint habit_challenge_members_habit_id_fkey 
        foreign key (habit_id) references public.habits_v2(id) on delete set null;
    end if;
  end if;
end $$;

-- CHALLENGE LEADERBOARD VIEW
create or replace view public.v_challenge_scores as
select m.challenge_id,
       m.user_id,
       p.display_name as user_display_name,
       coalesce(
         case c.scoring
           when 'sum' then (select sum(value) from habit_logs_v2 l
                            where l.user_id=m.user_id
                              and (m.habit_id is null or l.habit_id=m.habit_id)
                              and l.date between c.start_date and c.end_date)
           else (select count(distinct l.date) from habit_logs_v2 l
                 where l.user_id=m.user_id
                   and (m.habit_id is null or l.habit_id=m.habit_id)
                   and l.done is true
                   and l.date between c.start_date and c.end_date)
         end
       ,0)::numeric as score
from habit_challenge_members m
join habit_challenges c on c.id=m.challenge_id
left join profiles p on p.user_id = m.user_id;

-- RLS
alter table public.habit_challenges enable row level security;
alter table public.habit_challenge_members enable row level security;

-- Challenge policies
drop policy if exists "owner or member read challenge" on public.habit_challenges;
create policy "owner or member read challenge" on public.habit_challenges
  for select using (
    auth.uid() = owner_id
    or exists(select 1 from habit_challenge_members m where m.challenge_id = habit_challenges.id and m.user_id = auth.uid())
  );

drop policy if exists "owner write challenge" on public.habit_challenges;
create policy "owner write challenge" on public.habit_challenges
  for all using (auth.uid() = owner_id) with check (auth.uid() = owner_id);

-- Member policies
drop policy if exists "member read" on public.habit_challenge_members;
create policy "member read" on public.habit_challenge_members
  for select using (
    auth.uid() = user_id 
    or auth.uid() = (select owner_id from habit_challenges where id=challenge_id)
  );

drop policy if exists "self upsert" on public.habit_challenge_members;
create policy "self upsert" on public.habit_challenge_members
  for insert with check (auth.uid() = user_id);

drop policy if exists "self delete" on public.habit_challenge_members;
create policy "self delete" on public.habit_challenge_members
  for delete using (
    auth.uid() = user_id 
    or auth.uid() = (select owner_id from habit_challenges where id=challenge_id)
  );
-- === END MIGRATION: 0003_challenges_autoprog.sql ===

-- === BEGIN MIGRATION: 0004_habits_v2_domain_goal.sql ===
-- ========================================================
-- HABITS MODULE - DOMAIN/GOAL COLUMNS
-- Migration 0004: Add domain_key and goal_id to habits_v2
-- 
-- Purpose: Support dashboard quick-add parity by adding
-- domain_key (life wheel category) and goal_id (linked goal)
-- columns to the unified habits_v2 table.
-- ========================================================

-- Add domain_key column if not exists
-- This links the habit to a life wheel domain/category
ALTER TABLE public.habits_v2 ADD COLUMN IF NOT EXISTS domain_key text;

-- Add goal_id column if not exists
-- This links the habit to a specific goal
ALTER TABLE public.habits_v2 ADD COLUMN IF NOT EXISTS goal_id uuid REFERENCES public.goals(id) ON DELETE SET NULL;

-- Create index on domain_key for faster filtering by domain
CREATE INDEX IF NOT EXISTS habits_v2_domain_key_idx ON public.habits_v2(domain_key);

-- Create index on goal_id for faster filtering by linked goal
CREATE INDEX IF NOT EXISTS habits_v2_goal_id_idx ON public.habits_v2(goal_id);
-- === END MIGRATION: 0004_habits_v2_domain_goal.sql ===

-- === BEGIN MIGRATION: 0005_habit_adjustments.sql ===
-- Migration: Add habit_adjustments table for storing performance classification suggestions
-- This table is optional and used for auditing suggestion history.
-- If this table doesn't exist, the application will gracefully no-op persistence operations.

CREATE TABLE IF NOT EXISTS public.habit_adjustments (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  habit_id uuid REFERENCES public.habits_v2(id) ON DELETE CASCADE,
  created_at timestamptz DEFAULT now(),
  classification text,
  suggested_action text,
  rationale text,
  old_schedule jsonb,
  new_schedule jsonb,
  old_target_num numeric,
  new_target_num numeric,
  applied boolean DEFAULT false
);

CREATE INDEX IF NOT EXISTS habit_adjustments_habit_id_idx ON public.habit_adjustments(habit_id);
-- === END MIGRATION: 0005_habit_adjustments.sql ===

-- === BEGIN MIGRATION: 0006_habit_adjustments_rollbacks.sql ===
-- Migration: Add rollback/revert support columns to habit_adjustments table
-- This migration adds audit fields for tracking when suggestions are applied and reverted.

-- Add applied_at column (timestamp when the suggestion was applied)
ALTER TABLE public.habit_adjustments ADD COLUMN IF NOT EXISTS applied_at timestamptz;

-- Add reverted column (flag indicating if the suggestion has been rolled back)
ALTER TABLE public.habit_adjustments ADD COLUMN IF NOT EXISTS reverted boolean DEFAULT false;

-- Add reverted_at column (timestamp when the suggestion was reverted)
ALTER TABLE public.habit_adjustments ADD COLUMN IF NOT EXISTS reverted_at timestamptz;

-- Add revert_rationale column (optional user-provided reason for reverting)
ALTER TABLE public.habit_adjustments ADD COLUMN IF NOT EXISTS revert_rationale text;

-- Note: For existing applied rows without applied_at, the service layer will backfill
-- applied_at = now() on first revert operation via COALESCE(applied_at, now()).
-- === END MIGRATION: 0006_habit_adjustments_rollbacks.sql ===

-- === BEGIN MIGRATION: 0007_reminder_prefs_and_state.sql ===
-- ========================================================
-- DAILY REMINDER SCHEDULING - USER PREFERENCES & STATE
-- Migration 0007: Per-user reminder preferences and habit reminder state
-- ========================================================

-- USER REMINDER PREFERENCES TABLE
-- Stores per-user timezone and daily reminder window settings
CREATE TABLE IF NOT EXISTS public.user_reminder_prefs (
  user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  timezone TEXT NOT NULL DEFAULT 'UTC',
  window_start TIME NOT NULL DEFAULT '08:00:00',
  window_end TIME NOT NULL DEFAULT '10:00:00',
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- HABIT REMINDER STATE TABLE
-- Tracks idempotent delivery to prevent duplicate reminders
CREATE TABLE IF NOT EXISTS public.habit_reminder_state (
  habit_id UUID PRIMARY KEY REFERENCES public.habits_v2(id) ON DELETE CASCADE,
  last_reminder_sent_at TIMESTAMPTZ,
  snooze_until TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- INDEXES
-- Index on user_id for fast lookups in user_reminder_prefs
CREATE INDEX IF NOT EXISTS idx_user_reminder_prefs_user_id 
  ON public.user_reminder_prefs(user_id);

-- Index on last_reminder_sent_at for efficient filtering of recently-reminded habits
CREATE INDEX IF NOT EXISTS idx_habit_reminder_state_last_sent 
  ON public.habit_reminder_state(last_reminder_sent_at);

-- Index on snooze_until for filtering snoozed habits
CREATE INDEX IF NOT EXISTS idx_habit_reminder_state_snooze 
  ON public.habit_reminder_state(snooze_until);

-- ROW LEVEL SECURITY
ALTER TABLE public.user_reminder_prefs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.habit_reminder_state ENABLE ROW LEVEL SECURITY;

-- USER REMINDER PREFS POLICIES
-- Users can only access and modify their own reminder preferences
DROP POLICY IF EXISTS "own_reminder_prefs" ON public.user_reminder_prefs;
CREATE POLICY "own_reminder_prefs" ON public.user_reminder_prefs
  FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

-- HABIT REMINDER STATE POLICIES
-- Users can only access reminder state for habits they own
DROP POLICY IF EXISTS "own_habit_reminder_state" ON public.habit_reminder_state;
CREATE POLICY "own_habit_reminder_state" ON public.habit_reminder_state
  FOR ALL USING (
    EXISTS (SELECT 1 FROM public.habits_v2 WHERE id = habit_id AND user_id = auth.uid())
  )
  WITH CHECK (
    EXISTS (SELECT 1 FROM public.habits_v2 WHERE id = habit_id AND user_id = auth.uid())
  );

-- UPDATED_AT TRIGGER FUNCTIONS
CREATE OR REPLACE FUNCTION public.set_user_reminder_prefs_updated_at()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN
  NEW.updated_at := now();
  RETURN NEW;
END;
$$;

CREATE OR REPLACE FUNCTION public.set_habit_reminder_state_updated_at()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN
  NEW.updated_at := now();
  RETURN NEW;
END;
$$;

-- UPDATED_AT TRIGGERS
DROP TRIGGER IF EXISTS user_reminder_prefs_updated_at ON public.user_reminder_prefs;
CREATE TRIGGER user_reminder_prefs_updated_at
  BEFORE UPDATE ON public.user_reminder_prefs
  FOR EACH ROW EXECUTE FUNCTION public.set_user_reminder_prefs_updated_at();

DROP TRIGGER IF EXISTS habit_reminder_state_updated_at ON public.habit_reminder_state;
CREATE TRIGGER habit_reminder_state_updated_at
  BEFORE UPDATE ON public.habit_reminder_state
  FOR EACH ROW EXECUTE FUNCTION public.set_habit_reminder_state_updated_at();
-- === END MIGRATION: 0007_reminder_prefs_and_state.sql ===

-- === BEGIN MIGRATION: 0008_per_habit_prefs_actions_logging.sql ===
-- ========================================================
-- PER-HABIT REMINDER PREFS, ACTION LOGS, AND DELIVERY FAILURES
-- Migration 0008: Actionable notifications, per-habit controls, delivery reliability
-- ========================================================

-- HABIT REMINDER PREFS TABLE
-- Stores per-habit reminder preferences (enable/disable, preferred time)
CREATE TABLE IF NOT EXISTS public.habit_reminder_prefs (
  habit_id UUID PRIMARY KEY REFERENCES public.habits_v2(id) ON DELETE CASCADE,
  enabled BOOLEAN NOT NULL DEFAULT true,
  preferred_time TIME NULL, -- optional per-habit preferred reminder time
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- REMINDER ACTION LOGS TABLE
-- Logs notification interactions (done, snooze, dismiss)
CREATE TABLE IF NOT EXISTS public.reminder_action_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  habit_id UUID NOT NULL REFERENCES public.habits_v2(id) ON DELETE CASCADE,
  action TEXT NOT NULL CHECK (action IN ('done', 'snooze', 'dismiss')),
  payload JSONB NULL,
  created_at TIMESTAMPTZ DEFAULT now()
);

-- REMINDER DELIVERY FAILURES TABLE (Dead-letter queue)
-- Logs persistent push notification delivery failures
CREATE TABLE IF NOT EXISTS public.reminder_delivery_failures (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  habit_id UUID NOT NULL REFERENCES public.habits_v2(id) ON DELETE CASCADE,
  endpoint TEXT NOT NULL,
  error TEXT NOT NULL,
  retry_count INT DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT now()
);

-- INDEXES
-- habit_reminder_prefs indexes
CREATE INDEX IF NOT EXISTS idx_habit_reminder_prefs_habit_id
  ON public.habit_reminder_prefs(habit_id);

-- reminder_action_logs indexes
CREATE INDEX IF NOT EXISTS idx_reminder_action_logs_user_id
  ON public.reminder_action_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_reminder_action_logs_habit_id
  ON public.reminder_action_logs(habit_id);
CREATE INDEX IF NOT EXISTS idx_reminder_action_logs_created_at
  ON public.reminder_action_logs(created_at);

-- reminder_delivery_failures indexes
CREATE INDEX IF NOT EXISTS idx_reminder_delivery_failures_user_id
  ON public.reminder_delivery_failures(user_id);
CREATE INDEX IF NOT EXISTS idx_reminder_delivery_failures_created_at
  ON public.reminder_delivery_failures(created_at);

-- ROW LEVEL SECURITY
ALTER TABLE public.habit_reminder_prefs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.reminder_action_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.reminder_delivery_failures ENABLE ROW LEVEL SECURITY;

-- HABIT REMINDER PREFS POLICIES
-- Users can read/write per-habit prefs for habits they own
DROP POLICY IF EXISTS "own_habit_reminder_prefs" ON public.habit_reminder_prefs;
CREATE POLICY "own_habit_reminder_prefs" ON public.habit_reminder_prefs
  FOR ALL USING (
    EXISTS (SELECT 1 FROM public.habits_v2 WHERE id = habit_id AND user_id = auth.uid())
  )
  WITH CHECK (
    EXISTS (SELECT 1 FROM public.habits_v2 WHERE id = habit_id AND user_id = auth.uid())
  );

-- REMINDER ACTION LOGS POLICIES
-- Users can read their own logs; inserts allowed via service role or own user
DROP POLICY IF EXISTS "own_reminder_action_logs_select" ON public.reminder_action_logs;
CREATE POLICY "own_reminder_action_logs_select" ON public.reminder_action_logs
  FOR SELECT USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "own_reminder_action_logs_insert" ON public.reminder_action_logs;
CREATE POLICY "own_reminder_action_logs_insert" ON public.reminder_action_logs
  FOR INSERT WITH CHECK (auth.uid() = user_id);

-- REMINDER DELIVERY FAILURES POLICIES
-- Users can read their own failure logs; inserts are service-role only
DROP POLICY IF EXISTS "own_reminder_delivery_failures_select" ON public.reminder_delivery_failures;
CREATE POLICY "own_reminder_delivery_failures_select" ON public.reminder_delivery_failures
  FOR SELECT USING (auth.uid() = user_id);

-- Service role bypass for inserts (service role has full access by default)
-- No additional policy needed for service role inserts

-- UPDATED_AT TRIGGER FUNCTIONS
CREATE OR REPLACE FUNCTION public.set_habit_reminder_prefs_updated_at()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN
  NEW.updated_at := now();
  RETURN NEW;
END;
$$;

-- UPDATED_AT TRIGGERS
DROP TRIGGER IF EXISTS habit_reminder_prefs_updated_at ON public.habit_reminder_prefs;
CREATE TRIGGER habit_reminder_prefs_updated_at
  BEFORE UPDATE ON public.habit_reminder_prefs
  FOR EACH ROW EXECUTE FUNCTION public.set_habit_reminder_prefs_updated_at();
-- === END MIGRATION: 0008_per_habit_prefs_actions_logging.sql ===

-- === BEGIN MIGRATION: 0009_reminder_analytics_views.sql ===
-- ========================================================
-- REMINDER ANALYTICS VIEWS
-- Migration 0009: Analytics layer for reminder effectiveness tracking
-- ========================================================

-- VIEW: reminder_actions_daily
-- Aggregates reminder action logs by day, user, habit, and action type
CREATE OR REPLACE VIEW public.reminder_actions_daily AS
SELECT 
  date_trunc('day', created_at)::date AS day,
  user_id,
  habit_id,
  action,
  count(*) AS action_count
FROM public.reminder_action_logs
GROUP BY 1, 2, 3, 4;

-- VIEW: reminder_sends_daily
-- Approximates daily reminder sends from habit_reminder_state (last_reminder_sent_at)
-- This tracks distinct habit reminders sent per user per day
CREATE OR REPLACE VIEW public.reminder_sends_daily AS
SELECT 
  date_trunc('day', last_reminder_sent_at)::date AS day,
  h.user_id,
  hrs.habit_id,
  1 AS sends
FROM public.habit_reminder_state hrs
INNER JOIN public.habits_v2 h ON h.id = hrs.habit_id
WHERE hrs.last_reminder_sent_at IS NOT NULL;

-- VIEW: reminder_failures_daily
-- Aggregates delivery failures by day and user
CREATE OR REPLACE VIEW public.reminder_failures_daily AS
SELECT 
  date_trunc('day', created_at)::date AS day,
  user_id,
  count(*) AS failures
FROM public.reminder_delivery_failures
GROUP BY 1, 2;

-- MATERIALIZED VIEW: reminder_metrics_aggregate_30d
-- Pre-aggregated 30-day metrics per user for efficient dashboard queries
-- Note: Requires periodic refresh via REFRESH MATERIALIZED VIEW CONCURRENTLY
CREATE MATERIALIZED VIEW IF NOT EXISTS public.reminder_metrics_aggregate_30d AS
WITH date_range AS (
  SELECT 
    current_date - interval '30 days' AS start_date,
    current_date AS end_date
),
user_sends AS (
  SELECT 
    s.user_id,
    count(DISTINCT (s.day, s.habit_id)) AS total_sends_30d
  FROM public.reminder_sends_daily s
  CROSS JOIN date_range dr
  WHERE s.day >= dr.start_date AND s.day <= dr.end_date
  GROUP BY s.user_id
),
user_actions AS (
  SELECT 
    a.user_id,
    count(*) AS total_actions_30d,
    count(*) FILTER (WHERE a.action = 'done') AS done_count_30d,
    count(*) FILTER (WHERE a.action = 'snooze') AS snooze_count_30d,
    count(*) FILTER (WHERE a.action = 'dismiss') AS dismiss_count_30d
  FROM public.reminder_actions_daily a
  CROSS JOIN date_range dr
  WHERE a.day >= dr.start_date AND a.day <= dr.end_date
  GROUP BY a.user_id
)
SELECT 
  COALESCE(us.user_id, ua.user_id) AS user_id,
  COALESCE(us.total_sends_30d, 0) AS total_sends_30d,
  COALESCE(ua.total_actions_30d, 0) AS total_actions_30d,
  COALESCE(ua.done_count_30d, 0) AS done_count_30d,
  COALESCE(ua.snooze_count_30d, 0) AS snooze_count_30d,
  COALESCE(ua.dismiss_count_30d, 0) AS dismiss_count_30d,
  CASE 
    WHEN COALESCE(ua.total_actions_30d, 0) > 0 
    THEN round((ua.done_count_30d::numeric / ua.total_actions_30d::numeric) * 100, 2)
    ELSE 0 
  END AS done_rate_30d,
  CASE 
    WHEN COALESCE(ua.total_actions_30d, 0) > 0 
    THEN round((ua.snooze_count_30d::numeric / ua.total_actions_30d::numeric) * 100, 2)
    ELSE 0 
  END AS snooze_rate_30d,
  CASE 
    WHEN COALESCE(ua.total_actions_30d, 0) > 0 
    THEN round((ua.dismiss_count_30d::numeric / ua.total_actions_30d::numeric) * 100, 2)
    ELSE 0 
  END AS dismiss_rate_30d,
  now() AS refreshed_at
FROM user_sends us
FULL OUTER JOIN user_actions ua ON us.user_id = ua.user_id;

-- Create unique index for CONCURRENTLY refresh support
CREATE UNIQUE INDEX IF NOT EXISTS idx_reminder_metrics_aggregate_30d_user_id 
  ON public.reminder_metrics_aggregate_30d(user_id);

-- ROW LEVEL SECURITY for views
-- Note: Views inherit RLS from underlying tables, but we add explicit policies for the materialized view

-- Enable RLS on the materialized view
ALTER MATERIALIZED VIEW public.reminder_metrics_aggregate_30d OWNER TO postgres;

-- SECURITY DEFINER function to get analytics for current user only
-- This ensures users can only see their own data
CREATE OR REPLACE FUNCTION public.get_reminder_analytics_summary(
  p_range_days integer DEFAULT 30
)
RETURNS TABLE (
  range_days integer,
  total_sends bigint,
  total_actions bigint,
  done_count bigint,
  snooze_count bigint,
  dismiss_count bigint,
  action_rate_pct numeric,
  done_rate_pct numeric,
  habits_with_prefs bigint,
  habits_enabled_pct numeric
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_start_date date;
BEGIN
  -- Get current user
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;
  
  -- Calculate start date
  v_start_date := current_date - (p_range_days || ' days')::interval;
  
  RETURN QUERY
  WITH sends AS (
    SELECT count(DISTINCT (s.day, s.habit_id)) AS cnt
    FROM reminder_sends_daily s
    WHERE s.user_id = v_user_id 
      AND s.day >= v_start_date 
      AND s.day <= current_date
  ),
  actions AS (
    SELECT 
      sum(a.action_count) AS total,
      sum(a.action_count) FILTER (WHERE a.action = 'done') AS done,
      sum(a.action_count) FILTER (WHERE a.action = 'snooze') AS snooze,
      sum(a.action_count) FILTER (WHERE a.action = 'dismiss') AS dismiss
    FROM reminder_actions_daily a
    WHERE a.user_id = v_user_id 
      AND a.day >= v_start_date 
      AND a.day <= current_date
  ),
  habit_prefs AS (
    SELECT 
      count(*) AS total_prefs,
      count(*) FILTER (WHERE hrp.enabled = true) AS enabled_prefs
    FROM habit_reminder_prefs hrp
    INNER JOIN habits_v2 h ON h.id = hrp.habit_id
    WHERE h.user_id = v_user_id AND h.archived = false
  )
  SELECT 
    p_range_days,
    COALESCE(s.cnt, 0)::bigint,
    COALESCE(a.total, 0)::bigint,
    COALESCE(a.done, 0)::bigint,
    COALESCE(a.snooze, 0)::bigint,
    COALESCE(a.dismiss, 0)::bigint,
    CASE 
      WHEN COALESCE(s.cnt, 0) > 0 
      THEN round((COALESCE(a.total, 0)::numeric / s.cnt::numeric) * 100, 2)
      ELSE 0 
    END,
    CASE 
      WHEN COALESCE(a.total, 0) > 0 
      THEN round((COALESCE(a.done, 0)::numeric / a.total::numeric) * 100, 2)
      ELSE 0 
    END,
    COALESCE(hp.total_prefs, 0)::bigint,
    CASE 
      WHEN COALESCE(hp.total_prefs, 0) > 0 
      THEN round((hp.enabled_prefs::numeric / hp.total_prefs::numeric) * 100, 2)
      ELSE 0 
    END
  FROM sends s
  CROSS JOIN actions a
  CROSS JOIN habit_prefs hp;
END;
$$;

-- Function to get daily analytics for current user
CREATE OR REPLACE FUNCTION public.get_reminder_analytics_daily(
  p_range_days integer DEFAULT 30
)
RETURNS TABLE (
  day date,
  sends bigint,
  done bigint,
  snooze bigint,
  dismiss bigint
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_start_date date;
BEGIN
  -- Get current user
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;
  
  -- Calculate start date
  v_start_date := current_date - (p_range_days || ' days')::interval;
  
  RETURN QUERY
  WITH date_series AS (
    SELECT generate_series(v_start_date, current_date, '1 day'::interval)::date AS day
  ),
  daily_sends AS (
    SELECT s.day, count(DISTINCT s.habit_id) AS sends
    FROM reminder_sends_daily s
    WHERE s.user_id = v_user_id 
      AND s.day >= v_start_date 
      AND s.day <= current_date
    GROUP BY s.day
  ),
  daily_actions AS (
    SELECT 
      a.day,
      sum(a.action_count) FILTER (WHERE a.action = 'done') AS done,
      sum(a.action_count) FILTER (WHERE a.action = 'snooze') AS snooze,
      sum(a.action_count) FILTER (WHERE a.action = 'dismiss') AS dismiss
    FROM reminder_actions_daily a
    WHERE a.user_id = v_user_id 
      AND a.day >= v_start_date 
      AND a.day <= current_date
    GROUP BY a.day
  )
  SELECT 
    ds.day,
    COALESCE(dsn.sends, 0)::bigint,
    COALESCE(da.done, 0)::bigint,
    COALESCE(da.snooze, 0)::bigint,
    COALESCE(da.dismiss, 0)::bigint
  FROM date_series ds
  LEFT JOIN daily_sends dsn ON dsn.day = ds.day
  LEFT JOIN daily_actions da ON da.day = ds.day
  ORDER BY ds.day;
END;
$$;

-- Grant execute permissions to authenticated users
GRANT EXECUTE ON FUNCTION public.get_reminder_analytics_summary(integer) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_reminder_analytics_daily(integer) TO authenticated;

-- Comment on objects for documentation
COMMENT ON VIEW public.reminder_actions_daily IS 'Daily aggregation of reminder action logs (done/snooze/dismiss) per user and habit';
COMMENT ON VIEW public.reminder_sends_daily IS 'Daily reminder sends approximated from habit_reminder_state last_reminder_sent_at';
COMMENT ON VIEW public.reminder_failures_daily IS 'Daily aggregation of reminder delivery failures per user';
COMMENT ON MATERIALIZED VIEW public.reminder_metrics_aggregate_30d IS 'Pre-computed 30-day reminder metrics per user. Refresh with: REFRESH MATERIALIZED VIEW CONCURRENTLY reminder_metrics_aggregate_30d;';
COMMENT ON FUNCTION public.get_reminder_analytics_summary IS 'Get aggregated reminder analytics for current user over specified range (7 or 30 days)';
COMMENT ON FUNCTION public.get_reminder_analytics_daily IS 'Get daily reminder analytics for current user over specified range, zero-filled for missing days';
-- === END MIGRATION: 0009_reminder_analytics_views.sql ===

-- === BEGIN MIGRATION: 0010_timezone_quiet_hours_weekends.sql ===
-- ========================================================
-- MIGRATION 0010: Timezone Quiet Hours & Weekend Skip
-- Purpose: Add quiet hours and weekend skip to user reminder preferences
-- ========================================================

-- Add new columns to user_reminder_prefs table
ALTER TABLE public.user_reminder_prefs
  ADD COLUMN IF NOT EXISTS quiet_hours_start TIME NULL,
  ADD COLUMN IF NOT EXISTS quiet_hours_end TIME NULL,
  ADD COLUMN IF NOT EXISTS skip_weekends BOOLEAN DEFAULT FALSE;

-- Add CHECK constraints for valid time values (00:00:00 to 23:59:59)
-- Quiet hours can have overnight ranges (e.g., 22:00 to 06:00)
-- Both start and end must be provided together, or both null

ALTER TABLE public.user_reminder_prefs
  DROP CONSTRAINT IF EXISTS chk_quiet_hours_both_or_neither;

ALTER TABLE public.user_reminder_prefs
  ADD CONSTRAINT chk_quiet_hours_both_or_neither
  CHECK (
    (quiet_hours_start IS NULL AND quiet_hours_end IS NULL) OR
    (quiet_hours_start IS NOT NULL AND quiet_hours_end IS NOT NULL)
  );

-- Note: We allow overnight ranges (e.g., 22:00 to 06:00) where start > end
-- The application logic handles this case by checking if current time is
-- either >= start OR <= end when start > end

-- Add comment explaining the quiet hours logic
COMMENT ON COLUMN public.user_reminder_prefs.quiet_hours_start IS 
  'Start time for quiet hours (no reminders). Supports overnight ranges where start > end (e.g., 22:00-06:00).';

COMMENT ON COLUMN public.user_reminder_prefs.quiet_hours_end IS 
  'End time for quiet hours (no reminders). Supports overnight ranges where start > end (e.g., 22:00-06:00).';

COMMENT ON COLUMN public.user_reminder_prefs.skip_weekends IS 
  'When true, reminders are not sent on Saturday (6) or Sunday (0).';

-- RLS policies already exist for user_reminder_prefs from migration 0007
-- The existing "own_reminder_prefs" policy covers all columns:
--   FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id)
-- No additional RLS changes needed.
-- === END MIGRATION: 0010_timezone_quiet_hours_weekends.sql ===

-- === BEGIN MIGRATION: 0011_merge_legacy_habits_into_v2.sql ===
-- ========================================================
-- HABITS MODULE - MERGE LEGACY HABITS INTO V2
-- Migration 0011: Migrate data from legacy habits tables to v2
-- 
-- Purpose: Consolidate the two habit systems into a single,
-- React-based Habits V2 implementation without loss of functionality,
-- preserving historical data and Today checklist UX in the PWA.
--
-- HARDENED: This migration is resilient to missing legacy tables.
-- It will run successfully whether or not legacy tables exist.
-- ========================================================

-- Step 1: Create migration map table to track old→new habit ID mappings
-- This allows us to maintain references and rollback if needed
CREATE TABLE IF NOT EXISTS public.habit_migration_map (
    old_habit_id uuid NOT NULL,
    new_habit_v2_id uuid NOT NULL,
    migrated_at timestamptz NOT NULL DEFAULT now(),
    migration_notes text,
    PRIMARY KEY (old_habit_id)
);

-- Index for reverse lookup (v2 ID → legacy ID)
CREATE INDEX IF NOT EXISTS idx_habit_migration_map_new_id 
    ON public.habit_migration_map(new_habit_v2_id);

-- RLS for migration map (admin-only access typically)
ALTER TABLE public.habit_migration_map ENABLE ROW LEVEL SECURITY;

-- Conditionally create the RLS policy only if public.habits table exists
-- If legacy habits table is absent, create a fallback policy
DO $$
BEGIN
    -- Drop any existing policy first
    DROP POLICY IF EXISTS "users_view_own_migrations" ON public.habit_migration_map;
    
    -- Check if public.habits table exists
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habits'
    ) THEN
        -- Legacy table exists: create policy that references it
        EXECUTE '
            CREATE POLICY "users_view_own_migrations" ON public.habit_migration_map
                FOR SELECT USING (
                    EXISTS (
                        SELECT 1 FROM public.habits h
                        JOIN public.goals g ON h.goal_id = g.id
                        WHERE h.id = habit_migration_map.old_habit_id 
                        AND g.user_id = auth.uid()
                    )
                )
        ';
        RAISE NOTICE 'Created migration_map policy using legacy habits table.';
    ELSE
        -- Legacy table does not exist: create fallback policy via habits_v2
        EXECUTE '
            CREATE POLICY "users_view_own_migrations" ON public.habit_migration_map
                FOR SELECT USING (
                    EXISTS (
                        SELECT 1 FROM public.habits_v2 h
                        WHERE h.id = habit_migration_map.new_habit_v2_id 
                        AND h.user_id = auth.uid()
                    )
                )
        ';
        RAISE NOTICE 'Legacy habits table absent. Created fallback migration_map policy using habits_v2.';
    END IF;
END $$;

-- ========================================================
-- Step 2: Migrate habits from public.habits → habits_v2
-- Field mappings:
--   habits.name → habits_v2.title
--   habits.goal_id → habits_v2.goal_id  
--   habits.frequency → used to derive schedule mode
--   habits.schedule → habits_v2.schedule (transformed)
--   type defaults to 'boolean' for legacy habits
--
-- GUARDED: Only runs if public.habits table exists
-- ========================================================

-- Function to convert legacy schedule JSON to v2 format
CREATE OR REPLACE FUNCTION migrate_legacy_schedule(
    legacy_frequency text,
    legacy_schedule jsonb
) RETURNS jsonb AS $$
DECLARE
    result jsonb;
    schedule_type text;
    days_array int[];
BEGIN
    -- Default to daily if no schedule specified
    IF legacy_schedule IS NULL OR legacy_schedule = 'null'::jsonb THEN
        RETURN '{"mode": "daily"}'::jsonb;
    END IF;

    -- Check for type field in schedule
    schedule_type := legacy_schedule->>'type';
    
    IF schedule_type = 'daily' THEN
        RETURN '{"mode": "daily"}'::jsonb;
    END IF;
    
    IF schedule_type = 'weekly' AND legacy_schedule->'days' IS NOT NULL THEN
        -- Convert day names to day indices
        SELECT ARRAY(
            SELECT CASE lower(d::text)
                WHEN '"sunday"' THEN 0
                WHEN '"sun"' THEN 0
                WHEN '"monday"' THEN 1
                WHEN '"mon"' THEN 1
                WHEN '"tuesday"' THEN 2
                WHEN '"tue"' THEN 2
                WHEN '"wednesday"' THEN 3
                WHEN '"wed"' THEN 3
                WHEN '"thursday"' THEN 4
                WHEN '"thu"' THEN 4
                WHEN '"friday"' THEN 5
                WHEN '"fri"' THEN 5
                WHEN '"saturday"' THEN 6
                WHEN '"sat"' THEN 6
                ELSE NULL
            END
            FROM jsonb_array_elements(legacy_schedule->'days') AS d
            WHERE d IS NOT NULL
        ) INTO days_array;
        
        IF array_length(days_array, 1) > 0 THEN
            RETURN jsonb_build_object('mode', 'specific_days', 'days', days_array);
        END IF;
    END IF;
    
    -- Check if schedule is already an array of days
    IF jsonb_typeof(legacy_schedule) = 'array' THEN
        SELECT ARRAY(
            SELECT CASE lower(d::text)
                WHEN '"sunday"' THEN 0
                WHEN '"sun"' THEN 0
                WHEN '"monday"' THEN 1
                WHEN '"mon"' THEN 1
                WHEN '"tuesday"' THEN 2
                WHEN '"tue"' THEN 2
                WHEN '"wednesday"' THEN 3
                WHEN '"wed"' THEN 3
                WHEN '"thursday"' THEN 4
                WHEN '"thu"' THEN 4
                WHEN '"friday"' THEN 5
                WHEN '"fri"' THEN 5
                WHEN '"saturday"' THEN 6
                WHEN '"sat"' THEN 6
                ELSE NULL
            END
            FROM jsonb_array_elements(legacy_schedule) AS d
        ) INTO days_array;
        
        IF array_length(days_array, 1) > 0 THEN
            RETURN jsonb_build_object('mode', 'specific_days', 'days', days_array);
        END IF;
    END IF;
    
    -- Fallback: parse frequency string
    IF legacy_frequency IS NOT NULL THEN
        IF lower(legacy_frequency) LIKE '%daily%' THEN
            RETURN '{"mode": "daily"}'::jsonb;
        ELSIF lower(legacy_frequency) LIKE '%weekly%' THEN
            -- Default to daily for generic weekly
            RETURN '{"mode": "daily"}'::jsonb;
        END IF;
    END IF;
    
    -- Default fallback
    RETURN '{"mode": "daily"}'::jsonb;
END;
$$ LANGUAGE plpgsql;

-- Perform the migration (only if legacy habits table exists)
DO $$
DECLARE
    legacy_habit RECORD;
    new_habit_id uuid;
    user_id_for_habit uuid;
    v2_schedule jsonb;
    habits_exist boolean;
BEGIN
    -- Check if public.habits table exists
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habits'
    ) INTO habits_exist;
    
    IF NOT habits_exist THEN
        RAISE NOTICE 'SKIP: Legacy public.habits table does not exist. No habits migration needed.';
        RETURN;
    END IF;
    
    -- Iterate through each legacy habit that hasn't been migrated
    FOR legacy_habit IN 
        SELECT h.id, h.goal_id, h.name, h.frequency, h.schedule
        FROM public.habits h
        LEFT JOIN public.habit_migration_map m ON h.id = m.old_habit_id
        WHERE m.old_habit_id IS NULL
    LOOP
        -- Get the user_id from the associated goal
        SELECT g.user_id INTO user_id_for_habit
        FROM public.goals g
        WHERE g.id = legacy_habit.goal_id;
        
        -- Skip if no user found (orphaned habit)
        IF user_id_for_habit IS NULL THEN
            CONTINUE;
        END IF;
        
        -- Convert schedule to v2 format
        v2_schedule := migrate_legacy_schedule(
            legacy_habit.frequency,
            legacy_habit.schedule::jsonb
        );
        
        -- Insert into habits_v2 (loop already filters unmigrated habits via LEFT JOIN)
        INSERT INTO public.habits_v2 (
            user_id,
            title,
            emoji,
            type,
            schedule,
            goal_id,
            archived,
            created_at
        ) VALUES (
            user_id_for_habit,
            legacy_habit.name,
            NULL, -- No emoji in legacy
            'boolean', -- Default type for legacy habits
            v2_schedule,
            legacy_habit.goal_id,
            false,
            now()
        )
        RETURNING id INTO new_habit_id;
        
        -- Record the mapping with ON CONFLICT for idempotency
        INSERT INTO public.habit_migration_map (old_habit_id, new_habit_v2_id, migration_notes)
        VALUES (legacy_habit.id, new_habit_id, 'Automated migration from legacy habits')
        ON CONFLICT (old_habit_id) DO NOTHING;
        
    END LOOP;
    
    RAISE NOTICE 'Legacy habits migration completed successfully.';
END $$;

-- ========================================================
-- Step 3: Migrate habit_logs from public.habit_logs → habit_logs_v2
-- Field mappings:
--   habit_logs.habit_id → lookup via migration_map → habit_logs_v2.habit_id
--   habit_logs.date → habit_logs_v2.date
--   habit_logs.completed → habit_logs_v2.done
--   value defaults to NULL (boolean logs)
--
-- GUARDED: Only runs if public.habit_logs table exists
-- ========================================================

DO $$
DECLARE
    legacy_log RECORD;
    new_habit_id uuid;
    user_id_for_habit uuid;
    habit_logs_exist boolean;
BEGIN
    -- Check if public.habit_logs table exists
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habit_logs'
    ) INTO habit_logs_exist;
    
    IF NOT habit_logs_exist THEN
        RAISE NOTICE 'SKIP: Legacy public.habit_logs table does not exist. No logs migration needed.';
        RETURN;
    END IF;
    
    -- Iterate through each legacy log for migrated habits
    FOR legacy_log IN 
        SELECT l.id, l.habit_id, l.date, l.completed, m.new_habit_v2_id
        FROM public.habit_logs l
        JOIN public.habit_migration_map m ON l.habit_id = m.old_habit_id
        LEFT JOIN public.habit_logs_v2 v2 ON 
            v2.habit_id = m.new_habit_v2_id AND 
            v2.date = l.date
        WHERE v2.id IS NULL -- Only migrate if not already present
    LOOP
        -- Get user_id from the v2 habit
        SELECT user_id INTO user_id_for_habit
        FROM public.habits_v2
        WHERE id = legacy_log.new_habit_v2_id;
        
        IF user_id_for_habit IS NOT NULL THEN
            -- Insert into habit_logs_v2 with ON CONFLICT handling
            INSERT INTO public.habit_logs_v2 (
                habit_id,
                user_id,
                date,
                done,
                value,
                note
            ) VALUES (
                legacy_log.new_habit_v2_id,
                user_id_for_habit,
                legacy_log.date,
                legacy_log.completed,
                NULL, -- No value in legacy logs
                'Migrated from legacy habit_logs'
            )
            ON CONFLICT DO NOTHING;
        END IF;
    END LOOP;
    
    RAISE NOTICE 'Legacy habit_logs migration completed successfully.';
END $$;

-- ========================================================
-- Step 4: Translate habit_alerts → habit_reminder_prefs
-- Field mappings:
--   habit_alerts.habit_id → lookup via migration_map → habit_reminder_prefs.habit_id
--   habit_alerts.alert_time → habit_reminder_prefs.preferred_time
--   habit_alerts.enabled → habit_reminder_prefs.enabled
--   habit_alerts.days_of_week → embedded in v2 schedule (best-effort)
--
-- GUARDED: Only runs if public.habit_alerts table exists
-- ========================================================

DO $$
DECLARE
    legacy_alert RECORD;
    new_habit_id uuid;
    habit_alerts_exist boolean;
BEGIN
    -- Check if public.habit_alerts table exists
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habit_alerts'
    ) INTO habit_alerts_exist;
    
    IF NOT habit_alerts_exist THEN
        RAISE NOTICE 'SKIP: Legacy public.habit_alerts table does not exist. No alerts migration needed.';
        RETURN;
    END IF;
    
    -- Iterate through each legacy alert for migrated habits
    FOR legacy_alert IN 
        SELECT a.id, a.habit_id, a.alert_time, a.enabled, a.days_of_week, m.new_habit_v2_id
        FROM public.habit_alerts a
        JOIN public.habit_migration_map m ON a.habit_id = m.old_habit_id
        LEFT JOIN public.habit_reminder_prefs p ON p.habit_id = m.new_habit_v2_id
        WHERE p.habit_id IS NULL -- Only migrate if not already present
    LOOP
        -- Insert into habit_reminder_prefs
        INSERT INTO public.habit_reminder_prefs (
            habit_id,
            enabled,
            preferred_time,
            created_at,
            updated_at
        ) VALUES (
            legacy_alert.new_habit_v2_id,
            legacy_alert.enabled,
            legacy_alert.alert_time,
            now(),
            now()
        )
        ON CONFLICT (habit_id) DO UPDATE SET
            enabled = EXCLUDED.enabled,
            preferred_time = EXCLUDED.preferred_time,
            updated_at = now();
    END LOOP;
    
    RAISE NOTICE 'Legacy habit_alerts migration completed successfully.';
END $$;

-- ========================================================
-- Step 5: Create read-only lock mechanism for legacy tables
-- Controlled via a feature flag row in a config table
--
-- GUARDED: Triggers are only created if legacy tables exist
-- ========================================================

-- Create config table for feature flags if not exists
CREATE TABLE IF NOT EXISTS public.app_config (
    key text PRIMARY KEY,
    value jsonb NOT NULL DEFAULT '{}'::jsonb,
    description text,
    updated_at timestamptz DEFAULT now()
);

-- Insert the legacy tables read-only flag (defaults to false/disabled)
INSERT INTO public.app_config (key, value, description)
VALUES (
    'legacy_habits_readonly',
    '{"enabled": false}'::jsonb,
    'When enabled, blocks INSERT/UPDATE/DELETE on legacy habits, habit_logs, and habit_alerts tables'
)
ON CONFLICT (key) DO NOTHING;

-- Function to check if legacy tables are read-only
CREATE OR REPLACE FUNCTION check_legacy_habits_readonly()
RETURNS TRIGGER AS $$
DECLARE
    is_readonly boolean;
BEGIN
    SELECT (value->>'enabled')::boolean INTO is_readonly
    FROM public.app_config
    WHERE key = 'legacy_habits_readonly';
    
    IF is_readonly = true THEN
        RAISE EXCEPTION 'Legacy habits tables are in read-only mode. Please use habits_v2 instead.';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add triggers to enforce read-only mode on legacy tables
-- GUARDED: Only create triggers if the corresponding tables exist

DO $$
BEGIN
    -- Guard trigger creation for public.habits
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habits'
    ) THEN
        DROP TRIGGER IF EXISTS enforce_readonly_habits ON public.habits;
        CREATE TRIGGER enforce_readonly_habits
            BEFORE INSERT OR UPDATE OR DELETE ON public.habits
            FOR EACH ROW
            EXECUTE FUNCTION check_legacy_habits_readonly();
        RAISE NOTICE 'Created read-only trigger on public.habits';
    ELSE
        RAISE NOTICE 'SKIP: public.habits does not exist. No trigger created.';
    END IF;
    
    -- Guard trigger creation for public.habit_logs
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habit_logs'
    ) THEN
        DROP TRIGGER IF EXISTS enforce_readonly_habit_logs ON public.habit_logs;
        CREATE TRIGGER enforce_readonly_habit_logs
            BEFORE INSERT OR UPDATE OR DELETE ON public.habit_logs
            FOR EACH ROW
            EXECUTE FUNCTION check_legacy_habits_readonly();
        RAISE NOTICE 'Created read-only trigger on public.habit_logs';
    ELSE
        RAISE NOTICE 'SKIP: public.habit_logs does not exist. No trigger created.';
    END IF;
    
    -- Guard trigger creation for public.habit_alerts
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habit_alerts'
    ) THEN
        DROP TRIGGER IF EXISTS enforce_readonly_habit_alerts ON public.habit_alerts;
        CREATE TRIGGER enforce_readonly_habit_alerts
            BEFORE INSERT OR UPDATE OR DELETE ON public.habit_alerts
            FOR EACH ROW
            EXECUTE FUNCTION check_legacy_habits_readonly();
        RAISE NOTICE 'Created read-only trigger on public.habit_alerts';
    ELSE
        RAISE NOTICE 'SKIP: public.habit_alerts does not exist. No trigger created.';
    END IF;
END $$;

-- ========================================================
-- Verification queries (as comments for manual verification)
-- ========================================================

-- Verify migration counts:
-- SELECT 
--     (SELECT COUNT(*) FROM public.habits) AS legacy_habits_count,
--     (SELECT COUNT(*) FROM public.habit_migration_map) AS migrated_count,
--     (SELECT COUNT(*) FROM public.habits_v2 WHERE goal_id IS NOT NULL) AS v2_with_goal_count;

-- Verify log migration:
-- SELECT
--     (SELECT COUNT(*) FROM public.habit_logs) AS legacy_logs_count,
--     (SELECT COUNT(*) FROM public.habit_logs_v2 WHERE note LIKE '%Migrated%') AS migrated_logs_count;

-- Verify alert migration:
-- SELECT
--     (SELECT COUNT(*) FROM public.habit_alerts) AS legacy_alerts_count,
--     (SELECT COUNT(*) FROM public.habit_reminder_prefs) AS v2_prefs_count;

-- Enable read-only mode (run manually after verification):
-- UPDATE public.app_config 
-- SET value = '{"enabled": true}'::jsonb, updated_at = now()
-- WHERE key = 'legacy_habits_readonly';

-- Disable read-only mode (for rollback):
-- UPDATE public.app_config 
-- SET value = '{"enabled": false}'::jsonb, updated_at = now()
-- WHERE key = 'legacy_habits_readonly';

COMMENT ON TABLE public.habit_migration_map IS 
'Tracks mapping of legacy habit IDs to v2 habit IDs for migration and rollback support.';

COMMENT ON TABLE public.app_config IS 
'Application configuration flags including legacy_habits_readonly for migration control.';
-- === END MIGRATION: 0011_merge_legacy_habits_into_v2.sql ===

-- === BEGIN MIGRATION: 0012_archive_and_drop_legacy_habits.sql ===
-- ========================================================
-- HABITS MODULE - ARCHIVE AND DROP LEGACY TABLES
-- Migration 0012: Post-merge cleanup
-- 
-- WARNING: This migration should ONLY be run after:
-- 1. Migration 0011 has been applied and verified
-- 2. Read-only mode has been enabled for 3-7 days
-- 3. All legacy habits data has been confirmed migrated
-- 4. The application has been updated to use habitsV2 exclusively
--
-- HARDENED: This migration is resilient to missing legacy tables 
-- and does NOT depend on app_config. All operations are guarded.
--
-- This migration:
-- 1. Archives legacy tables (creates backup copies) - IF THEY EXIST
-- 2. Drops the legacy tables, indexes, triggers, and RLS policies
-- 3. Cleans up any remaining references
-- ========================================================

-- Step 0: Safety check and information notice
-- No longer requires app_config - just logs status
DO $$
DECLARE
    app_config_exists boolean;
    readonly_enabled boolean;
BEGIN
    -- Check if app_config table exists
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'app_config'
    ) INTO app_config_exists;
    
    IF app_config_exists THEN
        SELECT (value->>'enabled')::boolean INTO readonly_enabled
        FROM public.app_config
        WHERE key = 'legacy_habits_readonly';
        
        IF readonly_enabled IS NULL OR readonly_enabled = false THEN
            RAISE NOTICE 'INFO: legacy_habits_readonly was not enabled in app_config.';
            RAISE NOTICE 'Proceeding with cleanup since this migration is designed to be resilient.';
        ELSE
            RAISE NOTICE 'INFO: legacy_habits_readonly was enabled. Proceeding with cleanup.';
        END IF;
    ELSE
        RAISE NOTICE 'INFO: app_config table does not exist. Proceeding with cleanup.';
    END IF;
END $$;

-- ========================================================
-- Step 1: Archive legacy tables (IF THEY EXIST)
-- Creates copies with _archived suffix for backup
-- ========================================================

-- Archive habits table (guarded)
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habits'
    ) THEN
        -- Only create archive if it doesn't exist yet
        IF NOT EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' AND table_name = 'habits_archived'
        ) THEN
            CREATE TABLE public.habits_archived AS 
            SELECT *, now() AS archived_at
            FROM public.habits;
            RAISE NOTICE 'Created archive: public.habits_archived';
        ELSE
            RAISE NOTICE 'Archive already exists: public.habits_archived - skipping.';
        END IF;
    ELSE
        RAISE NOTICE 'SKIP: public.habits does not exist. No archive needed.';
    END IF;
END $$;

-- Archive habit_logs table (guarded)
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habit_logs'
    ) THEN
        IF NOT EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' AND table_name = 'habit_logs_archived'
        ) THEN
            CREATE TABLE public.habit_logs_archived AS
            SELECT *, now() AS archived_at
            FROM public.habit_logs;
            RAISE NOTICE 'Created archive: public.habit_logs_archived';
        ELSE
            RAISE NOTICE 'Archive already exists: public.habit_logs_archived - skipping.';
        END IF;
    ELSE
        RAISE NOTICE 'SKIP: public.habit_logs does not exist. No archive needed.';
    END IF;
END $$;

-- Archive habit_alerts table (guarded)
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habit_alerts'
    ) THEN
        IF NOT EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' AND table_name = 'habit_alerts_archived'
        ) THEN
            CREATE TABLE public.habit_alerts_archived AS
            SELECT *, now() AS archived_at
            FROM public.habit_alerts;
            RAISE NOTICE 'Created archive: public.habit_alerts_archived';
        ELSE
            RAISE NOTICE 'Archive already exists: public.habit_alerts_archived - skipping.';
        END IF;
    ELSE
        RAISE NOTICE 'SKIP: public.habit_alerts does not exist. No archive needed.';
    END IF;
END $$;

-- Add comments to archived tables (if they exist)
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habits_archived'
    ) THEN
        COMMENT ON TABLE public.habits_archived IS 
        'Archived copy of legacy habits table. Created during v2 migration cleanup.';
    END IF;
    
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habit_logs_archived'
    ) THEN
        COMMENT ON TABLE public.habit_logs_archived IS 
        'Archived copy of legacy habit_logs table. Created during v2 migration cleanup.';
    END IF;
    
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habit_alerts_archived'
    ) THEN
        COMMENT ON TABLE public.habit_alerts_archived IS 
        'Archived copy of legacy habit_alerts table. Created during v2 migration cleanup.';
    END IF;
END $$;

-- ========================================================
-- Step 2: Drop triggers from legacy tables (guarded)
-- ========================================================

DO $$
BEGIN
    -- Drop read-only enforcement triggers (only if tables exist)
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habits'
    ) THEN
        DROP TRIGGER IF EXISTS enforce_readonly_habits ON public.habits;
        RAISE NOTICE 'Dropped trigger enforce_readonly_habits from public.habits';
    END IF;
    
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habit_logs'
    ) THEN
        DROP TRIGGER IF EXISTS enforce_readonly_habit_logs ON public.habit_logs;
        RAISE NOTICE 'Dropped trigger enforce_readonly_habit_logs from public.habit_logs';
    END IF;
    
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habit_alerts'
    ) THEN
        DROP TRIGGER IF EXISTS enforce_readonly_habit_alerts ON public.habit_alerts;
        RAISE NOTICE 'Dropped trigger enforce_readonly_habit_alerts from public.habit_alerts';
    END IF;
END $$;

-- ========================================================
-- Step 3: Drop RLS policies from legacy tables (guarded)
-- ========================================================

-- Drop any RLS policies on habits (if table exists)
DO $$
DECLARE
    policy_record RECORD;
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habits'
    ) THEN
        FOR policy_record IN 
            SELECT policyname 
            FROM pg_policies 
            WHERE tablename = 'habits' AND schemaname = 'public'
        LOOP
            EXECUTE format('DROP POLICY IF EXISTS %I ON public.habits', policy_record.policyname);
            RAISE NOTICE 'Dropped policy % from public.habits', policy_record.policyname;
        END LOOP;
    END IF;
END $$;

-- Drop any RLS policies on habit_logs (if table exists)
DO $$
DECLARE
    policy_record RECORD;
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habit_logs'
    ) THEN
        FOR policy_record IN 
            SELECT policyname 
            FROM pg_policies 
            WHERE tablename = 'habit_logs' AND schemaname = 'public'
        LOOP
            EXECUTE format('DROP POLICY IF EXISTS %I ON public.habit_logs', policy_record.policyname);
            RAISE NOTICE 'Dropped policy % from public.habit_logs', policy_record.policyname;
        END LOOP;
    END IF;
END $$;

-- Drop any RLS policies on habit_alerts (if table exists)
DO $$
DECLARE
    policy_record RECORD;
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habit_alerts'
    ) THEN
        FOR policy_record IN 
            SELECT policyname 
            FROM pg_policies 
            WHERE tablename = 'habit_alerts' AND schemaname = 'public'
        LOOP
            EXECUTE format('DROP POLICY IF EXISTS %I ON public.habit_alerts', policy_record.policyname);
            RAISE NOTICE 'Dropped policy % from public.habit_alerts', policy_record.policyname;
        END LOOP;
    END IF;
END $$;

-- ========================================================
-- Step 4: Drop indexes from legacy tables
-- Using IF EXISTS for all - safe even if they don't exist
-- ========================================================

-- Common index patterns to drop
DROP INDEX IF EXISTS public.idx_habits_goal_id;
DROP INDEX IF EXISTS public.idx_habits_name;
DROP INDEX IF EXISTS public.habits_goal_id_idx;

DROP INDEX IF EXISTS public.idx_habit_logs_habit_id;
DROP INDEX IF EXISTS public.idx_habit_logs_date;
DROP INDEX IF EXISTS public.idx_habit_logs_habit_date;
DROP INDEX IF EXISTS public.habit_logs_habit_id_idx;
DROP INDEX IF EXISTS public.habit_logs_date_idx;

DROP INDEX IF EXISTS public.idx_habit_alerts_habit_id;
DROP INDEX IF EXISTS public.idx_habit_alerts_alert_time;
DROP INDEX IF EXISTS public.habit_alerts_habit_id_idx;

-- ========================================================
-- Step 5: Drop legacy tables
-- Using IF EXISTS CASCADE - safe even if they don't exist
-- ========================================================

-- Drop habit_alerts first (no foreign key dependencies)
DROP TABLE IF EXISTS public.habit_alerts CASCADE;

-- Drop habit_logs (depends on habits)
DROP TABLE IF EXISTS public.habit_logs CASCADE;

-- Drop habits (has foreign key to goals)
DROP TABLE IF EXISTS public.habits CASCADE;

-- Log completion of table drops
DO $$
BEGIN
    RAISE NOTICE 'Legacy tables dropped (if they existed).';
END $$;

-- ========================================================
-- Step 6: Clean up helper functions
-- ========================================================

-- Drop the read-only check function (no longer needed)
DROP FUNCTION IF EXISTS public.check_legacy_habits_readonly();

-- Drop the legacy schedule migration function (no longer needed)
DROP FUNCTION IF EXISTS public.migrate_legacy_schedule(text, jsonb);

-- ========================================================
-- Step 7: Update app_config to mark cleanup complete (if exists)
-- This step is optional - migration works without app_config
-- ========================================================

DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'app_config'
    ) THEN
        -- Update the legacy_habits_readonly flag
        UPDATE public.app_config 
        SET value = jsonb_build_object(
            'enabled', false,
            'cleanup_completed_at', now()::text,
            'cleanup_migration', '0012_archive_and_drop_legacy_habits.sql'
        ),
            updated_at = now()
        WHERE key = 'legacy_habits_readonly';
        
        -- Add a new config entry to track cleanup status
        INSERT INTO public.app_config (key, value, description)
        VALUES (
            'legacy_habits_cleanup_status',
            jsonb_build_object(
                'status', 'completed',
                'completed_at', now()::text,
                'archived_tables', ARRAY['habits_archived', 'habit_logs_archived', 'habit_alerts_archived']
            ),
            'Tracks the status of legacy habits cleanup migration'
        )
        ON CONFLICT (key) DO UPDATE SET
            value = EXCLUDED.value,
            updated_at = now();
        
        RAISE NOTICE 'Updated app_config with cleanup status.';
    ELSE
        RAISE NOTICE 'SKIP: app_config table does not exist. Cleanup status not recorded.';
    END IF;
END $$;

-- ========================================================
-- Verification queries (run after migration)
-- ========================================================

/*
-- Verify legacy tables are dropped:
SELECT table_name 
FROM information_schema.tables 
WHERE table_schema = 'public' 
  AND table_name IN ('habits', 'habit_logs', 'habit_alerts');
-- Expected: Empty result set

-- Verify archived tables exist (if legacy tables existed):
SELECT table_name 
FROM information_schema.tables 
WHERE table_schema = 'public' 
  AND table_name IN ('habits_archived', 'habit_logs_archived', 'habit_alerts_archived');
-- Expected: Up to 3 rows (only for tables that existed)

-- Verify migration map exists and has data:
SELECT COUNT(*) AS migration_count FROM public.habit_migration_map;
-- Expected: Count > 0 if there were legacy habits

-- Verify v2 tables are intact:
SELECT 
    (SELECT COUNT(*) FROM public.habits_v2) AS v2_habits,
    (SELECT COUNT(*) FROM public.habit_logs_v2) AS v2_logs,
    (SELECT COUNT(*) FROM public.habit_reminder_prefs) AS v2_reminder_prefs;

-- Verify no remaining RLS policies on dropped tables:
SELECT schemaname, tablename, policyname
FROM pg_policies
WHERE tablename IN ('habits', 'habit_logs', 'habit_alerts')
  AND schemaname = 'public';
-- Expected: Empty result set

-- Check cleanup status (if app_config exists):
SELECT key, value, updated_at 
FROM public.app_config 
WHERE key IN ('legacy_habits_readonly', 'legacy_habits_cleanup_status');
*/

-- ========================================================
-- Rollback instructions (if needed)
-- ========================================================

/*
ROLLBACK STEPS (execute manually if rollback is required):

1. Restore habits table from archive (if archive exists):
CREATE TABLE public.habits AS 
SELECT id, goal_id, name, frequency, schedule 
FROM public.habits_archived;

2. Restore habit_logs table from archive (if archive exists):
CREATE TABLE public.habit_logs AS 
SELECT id, habit_id, date, completed 
FROM public.habit_logs_archived;

3. Restore habit_alerts table from archive (if archive exists):
CREATE TABLE public.habit_alerts AS 
SELECT id, habit_id, alert_time, days_of_week, enabled, created_at, updated_at 
FROM public.habit_alerts_archived;

4. Add necessary constraints and indexes back manually.

5. Update app_config (if it exists):
UPDATE public.app_config 
SET value = '{"status": "rolled_back"}'::jsonb
WHERE key = 'legacy_habits_cleanup_status';

NOTE: If rollback is needed, consider whether to keep the migrated v2 data
or revert to using only legacy tables.
*/

-- Add final comments to archived tables (safe to call even if tables don't exist)
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habits_archived'
    ) THEN
        COMMENT ON TABLE public.habits_archived IS 
        'Archived legacy habits table. Safe to drop after confirming v2 migration success (recommend 30+ days).';
    END IF;
    
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habit_logs_archived'
    ) THEN
        COMMENT ON TABLE public.habit_logs_archived IS 
        'Archived legacy habit_logs table. Safe to drop after confirming v2 migration success (recommend 30+ days).';
    END IF;
    
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'habit_alerts_archived'
    ) THEN
        COMMENT ON TABLE public.habit_alerts_archived IS 
        'Archived legacy habit_alerts table. Safe to drop after confirming v2 migration success (recommend 30+ days).';
    END IF;
    
    RAISE NOTICE 'Migration 0012 completed successfully.';
END $$;
-- === END MIGRATION: 0012_archive_and_drop_legacy_habits.sql ===

-- === BEGIN MIGRATION: 0101_vision_core.sql ===
-- Ensure tz on profiles
do $$ begin
  alter table public.profiles add column if not exists tz text default 'UTC';
exception when others then null; end $$;

do $$
begin
  begin
    create type vb_board_type as enum ('vision','focus');
  exception when duplicate_object then
    null;
  end;
end$$;

do $$
begin
  begin
    create type vb_card_size as enum ('S','M','L','XL');
  exception when duplicate_object then
    null;
  end;
end$$;

create table if not exists public.vb_boards (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  title text not null,
  board_type vb_board_type not null default 'vision',
  theme jsonb default '{}'::jsonb,
  cover_card_id uuid,
  archived boolean default false,
  created_at timestamptz default now()
);

create table if not exists public.vb_sections (
  id uuid primary key default gen_random_uuid(),
  board_id uuid not null references public.vb_boards(id) on delete cascade,
  title text not null,
  sort_index int default 0
);

create table if not exists public.vb_cards (
  id uuid primary key default gen_random_uuid(),
  board_id uuid not null references public.vb_boards(id) on delete cascade,
  section_id uuid references public.vb_sections(id) on delete set null,
  user_id uuid not null references auth.users(id) on delete cascade,
  kind text not null default 'image',       -- 'image' | 'text'
  title text,
  affirm text,
  color text,
  tags text[] default '{}',
  size vb_card_size default 'M',
  favorite boolean default false,
  visible_in_share boolean default true,
  link_type text,                           -- 'habit' | 'goal' | null
  link_id uuid,
  img_path text,
  img_w int, img_h int,
  sort_index int default 0,
  created_at timestamptz default now()
);

create or replace view public.vb_board_stats as
  select b.id board_id,
         count(c.*) as card_count,
         coalesce(sum(case when c.favorite then 1 else 0 end),0) as favorite_count
  from vb_boards b
  left join vb_cards c on c.board_id=b.id
  group by b.id;

-- RLS
alter table public.vb_boards enable row level security;
alter table public.vb_sections enable row level security;
alter table public.vb_cards enable row level security;

do $$
begin
  if exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'vb_boards'
      and policyname = 'own boards'
  ) then
    execute 'drop policy "own boards" on public.vb_boards';
  end if;
end $$;

create policy "own boards" on public.vb_boards
  for all using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

do $$
begin
  if exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'vb_sections'
      and policyname = 'sections of own boards'
  ) then
    execute 'drop policy "sections of own boards" on public.vb_sections';
  end if;
end $$;

do $$
begin
  if exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'vb_cards'
      and policyname = 'own cards'
  ) then
    execute 'drop policy "own cards" on public.vb_cards';
  end if;
end $$;

do $$
begin
  if exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'vb_cards'
      and policyname = 'own cards'
  ) then
    execute 'drop policy "own cards" on public.vb_cards';
  end if;
end $$;

create policy "own cards" on public.vb_cards
  for all using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

do $$ begin perform gen_random_uuid(); exception when undefined_function then
  create extension if not exists pgcrypto; end $$;
-- === END MIGRATION: 0101_vision_core.sql ===

-- === BEGIN MIGRATION: 0102_sharing_push.sql ===
create table if not exists public.vb_shares (
  id uuid primary key default gen_random_uuid(),
  board_id uuid not null references public.vb_boards(id) on delete cascade,
  owner_id uuid not null references auth.users(id) on delete cascade,
  slug text unique not null,
  is_active boolean default true,
  created_at timestamptz default now()
);
alter table public.vb_shares enable row level security;
do $$
begin
  if exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'vb_shares'
      and policyname = 'owner manage share'
  ) then
    execute 'drop policy "owner manage share" on public.vb_shares';
  end if;
end$$ language plpgsql;
create policy "owner manage share" on public.vb_shares
  for all using (auth.uid() = owner_id) with check (auth.uid() = owner_id);

create table if not exists public.push_subscriptions (
  user_id uuid not null references auth.users(id) on delete cascade,
  endpoint text primary key,
  p256dh text not null,
  auth text not null,
  created_at timestamptz default now()
);
alter table public.push_subscriptions enable row level security;
do $$
begin
  if exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'push_subscriptions'
      and policyname = 'own push'
  ) then
    execute 'drop policy "own push" on public.push_subscriptions';
  end if;
end$$ language plpgsql;
create policy "own push" on public.push_subscriptions
  for all using (auth.uid() = user_id) with check (auth.uid() = user_id);
-- === END MIGRATION: 0102_sharing_push.sql ===

-- === BEGIN MIGRATION: 0103_gratitude_mood.sql ===
create table if not exists public.vb_checkins (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  board_id uuid references public.vb_boards(id) on delete set null,
  the_date date not null default current_date,
  mood int check (mood between 1 and 5),
  gratitude text,
  created_at timestamptz default now()
);

create unique index if not exists vb_checkins_user_date_board_idx
  on public.vb_checkins (user_id, the_date, coalesce(board_id, '00000000-0000-0000-0000-000000000000'::uuid));
alter table public.vb_checkins enable row level security;
drop policy if exists "own checkins" on public.vb_checkins;
create policy "own checkins" on public.vb_checkins
  for all using (auth.uid() = user_id) with check (auth.uid() = user_id);
-- === END MIGRATION: 0103_gratitude_mood.sql ===

-- === BEGIN MIGRATION: 0104_life_goals_extended.sql ===
-- Migration: Extended Life Goals with Steps, Substeps, and Alerts
-- This migration adds support for detailed life goals with steps, timing, and PWA notifications

-- Create life_goal_steps table for managing goal steps
create table if not exists public.life_goal_steps (
  id uuid primary key default gen_random_uuid(),
  goal_id uuid not null references public.goals (id) on delete cascade,
  step_order int not null default 0,
  title text not null,
  description text,
  completed boolean not null default false,
  completed_at timestamptz,
  due_date date,
  created_at timestamptz not null default timezone('utc', now())
);

-- Create life_goal_substeps table for managing substeps
create table if not exists public.life_goal_substeps (
  id uuid primary key default gen_random_uuid(),
  step_id uuid not null references public.life_goal_steps (id) on delete cascade,
  substep_order int not null default 0,
  title text not null,
  completed boolean not null default false,
  completed_at timestamptz,
  created_at timestamptz not null default timezone('utc', now())
);

-- Create life_goal_alerts table for managing goal alerts and notifications
create table if not exists public.life_goal_alerts (
  id uuid primary key default gen_random_uuid(),
  goal_id uuid not null references public.goals (id) on delete cascade,
  user_id uuid not null references auth.users (id) on delete cascade,
  alert_type text not null, -- 'milestone', 'deadline', 'reminder', 'custom'
  alert_time timestamptz not null,
  title text not null,
  message text,
  sent boolean not null default false,
  sent_at timestamptz,
  repeat_pattern text, -- 'once', 'daily', 'weekly', 'monthly'
  enabled boolean not null default true,
  created_at timestamptz not null default timezone('utc', now())
);

-- Add new columns to goals table for extended features
alter table public.goals
  add column if not exists life_wheel_category text,
  add column if not exists start_date date,
  add column if not exists timing_notes text,
  add column if not exists estimated_duration_days int;

-- Create index for faster queries
create index if not exists life_goal_steps_goal_id_idx on public.life_goal_steps (goal_id);
create index if not exists life_goal_substeps_step_id_idx on public.life_goal_substeps (step_id);
create index if not exists life_goal_alerts_goal_id_idx on public.life_goal_alerts (goal_id);
create index if not exists life_goal_alerts_user_id_idx on public.life_goal_alerts (user_id);
create index if not exists life_goal_alerts_alert_time_idx on public.life_goal_alerts (alert_time);
create index if not exists goals_life_wheel_category_idx on public.goals (life_wheel_category);

-- Add RLS policies for life_goal_steps
alter table public.life_goal_steps enable row level security;

drop policy if exists "Users can view steps for their own goals" on public.life_goal_steps;
create policy "Users can view steps for their own goals"
  on public.life_goal_steps for select
  using (
    exists (
      select 1 from public.goals
      where goals.id = life_goal_steps.goal_id
      and goals.user_id = auth.uid()
    )
  );

drop policy if exists "Users can insert steps for their own goals" on public.life_goal_steps;
create policy "Users can insert steps for their own goals"
  on public.life_goal_steps for insert
  with check (
    exists (
      select 1 from public.goals
      where goals.id = life_goal_steps.goal_id
      and goals.user_id = auth.uid()
    )
  );

drop policy if exists "Users can update steps for their own goals" on public.life_goal_steps;
create policy "Users can update steps for their own goals"
  on public.life_goal_steps for update
  using (
    exists (
      select 1 from public.goals
      where goals.id = life_goal_steps.goal_id
      and goals.user_id = auth.uid()
    )
  );

drop policy if exists "Users can delete steps for their own goals" on public.life_goal_steps;
create policy "Users can delete steps for their own goals"
  on public.life_goal_steps for delete
  using (
    exists (
      select 1 from public.goals
      where goals.id = life_goal_steps.goal_id
      and goals.user_id = auth.uid()
    )
  );

-- Add RLS policies for life_goal_substeps
alter table public.life_goal_substeps enable row level security;

drop policy if exists "Users can view substeps for their own goals" on public.life_goal_substeps;
create policy "Users can view substeps for their own goals"
  on public.life_goal_substeps for select
  using (
    exists (
      select 1 from public.life_goal_steps
      join public.goals on goals.id = life_goal_steps.goal_id
      where life_goal_steps.id = life_goal_substeps.step_id
      and goals.user_id = auth.uid()
    )
  );

drop policy if exists "Users can insert substeps for their own goals" on public.life_goal_substeps;
create policy "Users can insert substeps for their own goals"
  on public.life_goal_substeps for insert
  with check (
    exists (
      select 1 from public.life_goal_steps
      join public.goals on goals.id = life_goal_steps.goal_id
      where life_goal_steps.id = life_goal_substeps.step_id
      and goals.user_id = auth.uid()
    )
  );

drop policy if exists "Users can update substeps for their own goals" on public.life_goal_substeps;
create policy "Users can update substeps for their own goals"
  on public.life_goal_substeps for update
  using (
    exists (
      select 1 from public.life_goal_steps
      join public.goals on goals.id = life_goal_steps.goal_id
      where life_goal_steps.id = life_goal_substeps.step_id
      and goals.user_id = auth.uid()
    )
  );

drop policy if exists "Users can delete substeps for their own goals" on public.life_goal_substeps;
create policy "Users can delete substeps for their own goals"
  on public.life_goal_substeps for delete
  using (
    exists (
      select 1 from public.life_goal_steps
      join public.goals on goals.id = life_goal_steps.goal_id
      where life_goal_steps.id = life_goal_substeps.step_id
      and goals.user_id = auth.uid()
    )
  );

-- Add RLS policies for life_goal_alerts
alter table public.life_goal_alerts enable row level security;

drop policy if exists "Users can view their own goal alerts" on public.life_goal_alerts;
create policy "Users can view their own goal alerts"
  on public.life_goal_alerts for select
  using (user_id = auth.uid());

drop policy if exists "Users can insert their own goal alerts" on public.life_goal_alerts;
create policy "Users can insert their own goal alerts"
  on public.life_goal_alerts for insert
  with check (user_id = auth.uid());

drop policy if exists "Users can update their own goal alerts" on public.life_goal_alerts;
create policy "Users can update their own goal alerts"
  on public.life_goal_alerts for update
  using (user_id = auth.uid());

drop policy if exists "Users can delete their own goal alerts" on public.life_goal_alerts;
create policy "Users can delete their own goal alerts"
  on public.life_goal_alerts for delete
  using (user_id = auth.uid());

-- Add comments for documentation
comment on table public.life_goal_steps is 'Steps for breaking down life goals into actionable tasks';
comment on table public.life_goal_substeps is 'Substeps for further breaking down goal steps';
comment on table public.life_goal_alerts is 'Alert and notification schedules for life goals (PWA compatible)';
comment on column public.goals.life_wheel_category is 'Links goal to a life wheel category (spirituality_community, finance_wealth, etc.)';
comment on column public.goals.start_date is 'When the user plans to start working on this goal';
comment on column public.goals.timing_notes is 'Detailed timing and schedule notes for the goal';
comment on column public.goals.estimated_duration_days is 'Estimated number of days to complete this goal';
-- === END MIGRATION: 0104_life_goals_extended.sql ===

-- === BEGIN MIGRATION: 0105_vision_images_url_support.sql ===
-- Add support for URL-based images in vision_images table
-- This migration adds columns to support both file uploads and external URLs

-- Add image_url column to store external image URLs
alter table public.vision_images add column if not exists image_url text;

-- Add image_source column to track whether the image is from a file or URL
-- Default to 'file' for backward compatibility with existing records
alter table public.vision_images add column if not exists image_source text default 'file';

-- Add check constraint to ensure image_source is either 'file' or 'url'
do $$ 
begin
  if not exists (
    select 1 from pg_constraint 
    where conname = 'vision_images_source_check' 
    and conrelid = 'public.vision_images'::regclass
  ) then
    alter table public.vision_images 
    add constraint vision_images_source_check 
    check (image_source in ('file', 'url'));
  end if;
end $$;

-- Add check constraint to ensure either image_path or image_url is set based on source
do $$ 
begin
  if not exists (
    select 1 from pg_constraint 
    where conname = 'vision_images_path_url_check' 
    and conrelid = 'public.vision_images'::regclass
  ) then
    alter table public.vision_images 
    add constraint vision_images_path_url_check 
    check (
      (image_source = 'file' and image_path is not null) or
      (image_source = 'url' and image_url is not null)
    );
  end if;
end $$;

-- Comment the columns for documentation
comment on column public.vision_images.image_url is 'External URL for images loaded from the web';
comment on column public.vision_images.image_source is 'Source type: file (uploaded to storage) or url (external link)';
-- === END MIGRATION: 0105_vision_images_url_support.sql ===

-- === BEGIN MIGRATION: 0106_journal_feature.sql ===
-- Journal entries table and policies

-- Ensure pgcrypto for gen_random_uuid
DO $$
BEGIN
  PERFORM gen_random_uuid();
EXCEPTION
  WHEN undefined_function THEN
    CREATE EXTENSION IF NOT EXISTS pgcrypto;
END$$;

-- Helper function to maintain updated_at
CREATE OR REPLACE FUNCTION public.set_journal_updated_at()
RETURNS trigger AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TABLE IF NOT EXISTS public.journal_entries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  entry_date date NOT NULL DEFAULT current_date,
  title text,
  content text NOT NULL,
  mood text,
  tags text[] DEFAULT '{}',
  is_private boolean NOT NULL DEFAULT true,
  attachments jsonb,
  linked_goal_ids text[] DEFAULT '{}',
  linked_habit_ids text[] DEFAULT '{}'
);

DROP TRIGGER IF EXISTS set_journal_entries_updated_at ON public.journal_entries;
CREATE TRIGGER set_journal_entries_updated_at
BEFORE UPDATE ON public.journal_entries
FOR EACH ROW
EXECUTE FUNCTION public.set_journal_updated_at();

ALTER TABLE public.journal_entries ENABLE ROW LEVEL SECURITY;

DO $$
BEGIN
  IF EXISTS (
    SELECT 1
    FROM pg_policies
    WHERE schemaname = 'public'
      AND tablename = 'journal_entries'
      AND policyname = 'own journal entries'
  ) THEN
    EXECUTE 'DROP POLICY "own journal entries" ON public.journal_entries';
  END IF;
END$$;

CREATE POLICY "own journal entries" ON public.journal_entries
  FOR ALL
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);
-- === END MIGRATION: 0106_journal_feature.sql ===

-- === BEGIN MIGRATION: 0107_workspace_profiles.sql ===
-- Workspace profiles table
-- Backfill workspace_profiles schema to match production fixes.
-- This ensures the upsert with onConflict: 'user_id' works correctly.

-- Create workspace_profiles table
CREATE TABLE IF NOT EXISTS public.workspace_profiles (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  display_name text,
  full_name text,
  workspace_name text,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

-- Create unique index on user_id to support onConflict upserts
-- This fixes the error: "there is no unique or exclusion constraint matching the ON CONFLICT specification"
CREATE UNIQUE INDEX IF NOT EXISTS workspace_profiles_user_id_key 
ON public.workspace_profiles (user_id);

-- Enable RLS
ALTER TABLE public.workspace_profiles ENABLE ROW LEVEL SECURITY;

-- Drop existing policy if it exists
DO $$
BEGIN
  IF EXISTS (
    SELECT 1
    FROM pg_policies
    WHERE schemaname = 'public'
      AND tablename = 'workspace_profiles'
      AND policyname = 'workspace_profiles_owner_all'
  ) THEN
    EXECUTE 'DROP POLICY "workspace_profiles_owner_all" ON public.workspace_profiles';
  END IF;
END$$;

-- Create RLS policy: users can only access their own workspace profile
CREATE POLICY "workspace_profiles_owner_all" 
ON public.workspace_profiles
AS PERMISSIVE
FOR ALL
TO public
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);
-- === END MIGRATION: 0107_workspace_profiles.sql ===

-- === BEGIN MIGRATION: 0108_ai_settings.sql ===
-- Migration: AI Settings
-- Description: Create ai_settings table for user-specific AI configurations
-- Required for: AI-powered goal suggestions and other AI features

-- Create ai_settings table
CREATE TABLE IF NOT EXISTS ai_settings (
  user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  provider TEXT NOT NULL DEFAULT 'openai',
  api_key TEXT,
  model TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add index on user_id for faster lookups
CREATE INDEX IF NOT EXISTS idx_ai_settings_user_id ON ai_settings(user_id);

-- Add index on provider for potential multi-provider support
CREATE INDEX IF NOT EXISTS idx_ai_settings_provider ON ai_settings(provider);

-- Enable Row Level Security
ALTER TABLE ai_settings ENABLE ROW LEVEL SECURITY;

-- Policy: Users can only read their own AI settings
CREATE POLICY "Users can view their own AI settings"
  ON ai_settings
  FOR SELECT
  USING (auth.uid() = user_id);

-- Policy: Users can insert their own AI settings
CREATE POLICY "Users can insert their own AI settings"
  ON ai_settings
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Policy: Users can update their own AI settings
CREATE POLICY "Users can update their own AI settings"
  ON ai_settings
  FOR UPDATE
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Policy: Users can delete their own AI settings
CREATE POLICY "Users can delete their own AI settings"
  ON ai_settings
  FOR DELETE
  USING (auth.uid() = user_id);

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_ai_settings_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically update updated_at
CREATE TRIGGER update_ai_settings_updated_at
  BEFORE UPDATE ON ai_settings
  FOR EACH ROW
  EXECUTE FUNCTION update_ai_settings_updated_at();

-- Add comments for documentation
COMMENT ON TABLE ai_settings IS 'User-specific AI provider configurations and API keys';
COMMENT ON COLUMN ai_settings.user_id IS 'Reference to the user who owns this configuration';
COMMENT ON COLUMN ai_settings.provider IS 'AI provider name (e.g., openai, anthropic)';
COMMENT ON COLUMN ai_settings.api_key IS 'User-provided API key for the AI provider (encrypted at rest)';
COMMENT ON COLUMN ai_settings.model IS 'Preferred AI model for this user (e.g., gpt-4o-mini, gpt-4o)';
COMMENT ON COLUMN ai_settings.created_at IS 'Timestamp when the settings were created';
COMMENT ON COLUMN ai_settings.updated_at IS 'Timestamp when the settings were last updated';
-- === END MIGRATION: 0108_ai_settings.sql ===

-- === BEGIN MIGRATION: 0109_habit_completions.sql ===
-- ========================================================
-- HABIT COMPLETIONS TABLE
-- Migration 0109: Per-day habit completion tracking (Path B)
-- ========================================================

-- Create habit_completions table
create table if not exists public.habit_completions (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  habit_id uuid not null references public.habits_v2(id) on delete cascade,
  completed_date date not null,
  completed boolean not null default true,
  created_at timestamptz not null default now(),
  unique (user_id, habit_id, completed_date)
);

-- Create indexes for better query performance
create index if not exists idx_habit_completions_user_id on public.habit_completions(user_id);
create index if not exists idx_habit_completions_habit_id on public.habit_completions(habit_id);
create index if not exists idx_habit_completions_date on public.habit_completions(completed_date);
create index if not exists idx_habit_completions_user_habit on public.habit_completions(user_id, habit_id);

-- Enable Row Level Security
alter table public.habit_completions enable row level security;

-- RLS Policy: Users can only access their own habit completions
drop policy if exists "own habit completions" on public.habit_completions;
create policy "own habit completions" on public.habit_completions
  for all using (auth.uid() = user_id) with check (auth.uid() = user_id);
-- === END MIGRATION: 0109_habit_completions.sql ===

-- === BEGIN MIGRATION: 0110_meditation_sessions.sql ===
-- Meditation sessions table and policies

-- Ensure pgcrypto for gen_random_uuid
DO $$
BEGIN
  PERFORM gen_random_uuid();
EXCEPTION
  WHEN undefined_function THEN
    CREATE EXTENSION IF NOT EXISTS pgcrypto;
END$$;

CREATE TABLE IF NOT EXISTS public.meditation_sessions (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  created_at timestamptz NOT NULL DEFAULT now(),
  session_date date NOT NULL DEFAULT current_date,
  session_type text NOT NULL DEFAULT 'breathing',
  duration_seconds integer NOT NULL,
  completed boolean NOT NULL DEFAULT true,
  notes text,
  CONSTRAINT meditation_sessions_duration_positive CHECK (duration_seconds > 0)
);

-- Enable RLS
ALTER TABLE public.meditation_sessions ENABLE ROW LEVEL SECURITY;

-- Drop existing policy if it exists
DO $$
BEGIN
  IF EXISTS (
    SELECT 1
    FROM pg_policies
    WHERE schemaname = 'public'
      AND tablename = 'meditation_sessions'
      AND policyname = 'own meditation sessions'
  ) THEN
    EXECUTE 'DROP POLICY "own meditation sessions" ON public.meditation_sessions';
  END IF;
END$$;

-- Create policy: users can only access their own meditation sessions
CREATE POLICY "own meditation sessions" ON public.meditation_sessions
  FOR ALL
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Create indexes for better query performance
CREATE INDEX IF NOT EXISTS idx_meditation_sessions_user_id ON public.meditation_sessions(user_id);
CREATE INDEX IF NOT EXISTS idx_meditation_sessions_session_date ON public.meditation_sessions(session_date DESC);

-- Add helpful comments
COMMENT ON TABLE public.meditation_sessions IS 'Stores completed meditation and breathing sessions for users';
COMMENT ON COLUMN public.meditation_sessions.session_type IS 'Type of meditation session (breathing, guided, etc.)';
COMMENT ON COLUMN public.meditation_sessions.duration_seconds IS 'Duration of the session in seconds';
COMMENT ON COLUMN public.meditation_sessions.completed IS 'Whether the session was completed or abandoned';
-- === END MIGRATION: 0110_meditation_sessions.sql ===

-- === BEGIN MIGRATION: 0111_meditation_reminders.sql ===
-- Meditation reminders table and policies

-- Ensure pgcrypto for gen_random_uuid
DO $$
BEGIN
  PERFORM gen_random_uuid();
EXCEPTION
  WHEN undefined_function THEN
    CREATE EXTENSION IF NOT EXISTS pgcrypto;
END$$;

-- Helper function to maintain updated_at
CREATE OR REPLACE FUNCTION public.set_meditation_reminders_updated_at()
RETURNS trigger AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TABLE IF NOT EXISTS public.meditation_reminders (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  enabled boolean NOT NULL DEFAULT true,
  time_of_day text NOT NULL DEFAULT '08:00',
  timezone text,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

-- Add index on user_id for fast lookups
CREATE INDEX IF NOT EXISTS idx_meditation_reminders_user_id ON public.meditation_reminders(user_id);

DROP TRIGGER IF EXISTS set_meditation_reminders_updated_at ON public.meditation_reminders;
CREATE TRIGGER set_meditation_reminders_updated_at
BEFORE UPDATE ON public.meditation_reminders
FOR EACH ROW
EXECUTE FUNCTION public.set_meditation_reminders_updated_at();

ALTER TABLE public.meditation_reminders ENABLE ROW LEVEL SECURITY;

DO $$
BEGIN
  IF EXISTS (
    SELECT 1
    FROM pg_policies
    WHERE schemaname = 'public'
      AND tablename = 'meditation_reminders'
      AND policyname = 'own meditation reminders'
  ) THEN
    EXECUTE 'DROP POLICY "own meditation reminders" ON public.meditation_reminders';
  END IF;
END$$;

CREATE POLICY "own meditation reminders" ON public.meditation_reminders
  FOR ALL
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Add helpful comments
COMMENT ON TABLE public.meditation_reminders IS 'Stores daily reminder preferences for meditation/breathing space feature';
COMMENT ON COLUMN public.meditation_reminders.enabled IS 'Whether the daily reminder is enabled';
COMMENT ON COLUMN public.meditation_reminders.time_of_day IS 'Time of day for the reminder in HH:MM format';
COMMENT ON COLUMN public.meditation_reminders.timezone IS 'User timezone for scheduling (optional)';
-- === END MIGRATION: 0111_meditation_reminders.sql ===

-- === BEGIN MIGRATION: 0112_journal_modes.sql ===
-- Migration 0112: Add support for multiple journal modes
-- Original path: sql/006_journal_modes.sql
-- This migration extends the journal_entries table to support different journaling modes
-- (quick, deep, brain_dump, life_wheel, secret, goal, time_capsule, standard)

-- Add new columns to journal_entries table
ALTER TABLE public.journal_entries
ADD COLUMN IF NOT EXISTS type text NOT NULL DEFAULT 'standard';

-- Numeric mood score on a 0-10 scale
-- Note: Using integer type to enforce whole numbers only (no fractional scores)
ALTER TABLE public.journal_entries
ADD COLUMN IF NOT EXISTS mood_score integer;

ALTER TABLE public.journal_entries
ADD COLUMN IF NOT EXISTS category text;

ALTER TABLE public.journal_entries
ADD COLUMN IF NOT EXISTS unlock_date timestamptz;

ALTER TABLE public.journal_entries
ADD COLUMN IF NOT EXISTS goal_id uuid;

-- Add constraints for data validation
-- Mood score should be between 0 and 10 if provided
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint 
    WHERE conname = 'journal_entries_mood_score_range'
    AND conrelid = 'public.journal_entries'::regclass
  ) THEN
    ALTER TABLE public.journal_entries
    ADD CONSTRAINT journal_entries_mood_score_range
    CHECK (mood_score IS NULL OR (mood_score >= 0 AND mood_score <= 10));
  END IF;
END $$;

-- Type should be one of the valid journal modes
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint 
    WHERE conname = 'journal_entries_type_allowed_values'
    AND conrelid = 'public.journal_entries'::regclass
  ) THEN
    ALTER TABLE public.journal_entries
    ADD CONSTRAINT journal_entries_type_allowed_values
    CHECK (type IN ('quick', 'deep', 'brain_dump', 'life_wheel', 'secret', 'goal', 'time_capsule', 'standard'));
  END IF;
END $$;

-- Foreign key constraint for goal_id
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint 
    WHERE conname = 'journal_entries_goal_id_fkey'
    AND conrelid = 'public.journal_entries'::regclass
  ) THEN
    ALTER TABLE public.journal_entries
    ADD CONSTRAINT journal_entries_goal_id_fkey
    FOREIGN KEY (goal_id) REFERENCES public.goals(id) ON DELETE SET NULL;
  END IF;
END $$;

-- Create an index on type for better query performance
CREATE INDEX IF NOT EXISTS idx_journal_entries_type ON public.journal_entries(type);

-- Create an index on goal_id for better query performance when filtering by goal
CREATE INDEX IF NOT EXISTS idx_journal_entries_goal_id ON public.journal_entries(goal_id);

-- Create an index on unlock_date for time capsule entries
CREATE INDEX IF NOT EXISTS idx_journal_entries_unlock_date ON public.journal_entries(unlock_date)
WHERE unlock_date IS NOT NULL;

-- Add comment to document the new fields
COMMENT ON COLUMN public.journal_entries.type IS 'Journal entry mode: quick, deep, brain_dump, life_wheel, secret, goal, time_capsule, or standard';
COMMENT ON COLUMN public.journal_entries.mood_score IS 'Numeric mood score on a 0-10 scale (separate from the string mood field)';
COMMENT ON COLUMN public.journal_entries.category IS 'Life Wheel category for life_wheel journal mode';
COMMENT ON COLUMN public.journal_entries.unlock_date IS 'Date when a time capsule entry becomes visible';
COMMENT ON COLUMN public.journal_entries.goal_id IS 'Primary goal reference for goal-specific journal entries. Use this for entries focused on a single goal. For entries that reference multiple goals, use the linked_goal_ids array instead.';
-- === END MIGRATION: 0112_journal_modes.sql ===
