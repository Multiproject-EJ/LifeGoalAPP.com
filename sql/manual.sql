-- Auto-generated manual bundle
-- Source: supabase/migrations/*.sql
-- Do not edit this file by hand.
-- Last generated: 2025-11-15T15:54:28.890Z

-- === BEGIN MIGRATION: 0001_habits_core.sql ===
-- ========================================================
-- HABITS MODULE - CORE SCHEMA
-- Migration 0001: Habits, Logs, Reminders, Profiles, Streaks
-- ========================================================

-- PROFILES TABLE (for user timezone and display name)
create table if not exists public.profiles (
  user_id uuid primary key references auth.users(id) on delete cascade,
  created_at timestamptz default now(),
  display_name text,
  tz text default 'UTC'
);

-- HABIT TYPE ENUM
do $$ begin
  create type habit_type as enum ('boolean','quantity','duration');
exception
  when duplicate_object then null;
end $$;

-- HABITS TABLE (enhanced version with new fields)
-- Note: We'll check if columns exist before adding to avoid conflicts with existing habits table
do $$
begin
  -- Check if we need to extend the existing habits table or create a new one
  if not exists (select 1 from information_schema.tables where table_schema = 'public' and table_name = 'habits_v2') then
    create table public.habits_v2 (
      id uuid primary key default gen_random_uuid(),
      user_id uuid not null references auth.users(id) on delete cascade,
      title text not null,
      emoji text,
      type habit_type not null default 'boolean',
      target_num numeric,
      target_unit text,
      schedule jsonb not null,
      allow_skip boolean default true,
      start_date date default current_date,
      archived boolean default false,
      created_at timestamptz default now(),
      autoprog jsonb -- For auto-progression config
    );
  end if;
end $$;

-- HABIT REMINDERS TABLE
create table if not exists public.habit_reminders (
  id uuid primary key default gen_random_uuid(),
  habit_id uuid not null,
  local_time time not null,
  days int[] default null,
  geo jsonb,
  created_at timestamptz default now()
);

-- Add foreign key constraint with proper check
do $$
begin
  if exists (select 1 from information_schema.tables where table_schema = 'public' and table_name = 'habits_v2') then
    if not exists (
      select 1 from information_schema.table_constraints 
      where constraint_name = 'habit_reminders_habit_id_fkey_v2' 
      and table_name = 'habit_reminders'
    ) then
      alter table public.habit_reminders add constraint habit_reminders_habit_id_fkey_v2 
        foreign key (habit_id) references public.habits_v2(id) on delete cascade;
    end if;
  end if;
end $$;

-- HABIT LOGS TABLE (enhanced version)
do $$
begin
  if not exists (select 1 from information_schema.tables where table_schema = 'public' and table_name = 'habit_logs_v2') then
    create table public.habit_logs_v2 (
      id uuid primary key default gen_random_uuid(),
      habit_id uuid not null references public.habits_v2(id) on delete cascade,
      user_id uuid not null references auth.users(id) on delete cascade,
      ts timestamptz not null default now(),
      date date not null,
      value numeric,
      done boolean not null default true,
      note text,
      mood int check (mood between 1 and 5)
    );

    create index idx_habit_logs_v2_habit_date on public.habit_logs_v2(habit_id, date);
    create index idx_habit_logs_v2_user_date on public.habit_logs_v2(user_id, date);
  end if;
end $$;

do $$
begin
  if exists (
    select 1 from information_schema.columns
    where table_schema = 'public'
      and table_name = 'habit_logs_v2'
      and column_name = 'date'
  ) then
    begin
      execute 'alter table public.habit_logs_v2 alter column date drop expression';
    exception
      when others then null;
    end;

    alter table public.habit_logs_v2
      alter column date set default ((timezone('UTC', now()))::date);
  end if;
end $$;

create or replace function public.set_habit_logs_v2_date()
returns trigger language plpgsql as $$
begin
  if new.ts is null then
    new.ts := now();
  end if;
  new.date := (timezone('UTC', new.ts)::date);
  return new;
end;
$$;

drop trigger if exists habit_logs_v2_set_date on public.habit_logs_v2;
create trigger habit_logs_v2_set_date
before insert or update on public.habit_logs_v2
for each row execute function public.set_habit_logs_v2_date();

-- STREAKS VIEW
create or replace view public.v_habit_streaks as
with daily as (
  select h.id habit_id, l.date, bool_or(l.done) as done
  from habits_v2 h
  left join habit_logs_v2 l on l.habit_id = h.id
  group by h.id, l.date
), gaps as (
  select habit_id, date, date - (row_number() over (partition by habit_id order by date))::int grp
  from daily where done is true
)
select habit_id,
       coalesce( (select count(*) from gaps g2
                  where g2.habit_id=g.habit_id
                    and g2.grp=(select max(grp) from gaps g3 where g3.habit_id=g.habit_id)), 0)::int as current_streak,
       coalesce( (select max(cnt) from (
                   select count(*) cnt from gaps g4 where g4.habit_id=g.habit_id group by grp
                 ) s), 0)::int as best_streak
from gaps g
group by habit_id;

-- RLS POLICIES
alter table public.habits_v2 enable row level security;
alter table public.habit_logs_v2 enable row level security;
alter table public.habit_reminders enable row level security;
alter table public.profiles enable row level security;

-- Profiles policies
drop policy if exists "own profiles" on public.profiles;
create policy "own profiles" on public.profiles
  for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

-- Habits policies
drop policy if exists "own habits v2" on public.habits_v2;
create policy "own habits v2" on public.habits_v2
  for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

-- Logs policies
drop policy if exists "own logs v2" on public.habit_logs_v2;
create policy "own logs v2" on public.habit_logs_v2
  for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

-- Reminders policies
drop policy if exists "own reminders v2" on public.habit_reminders;
create policy "own reminders v2" on public.habit_reminders
  for all using (
    exists (select 1 from habits_v2 where id = habit_id and user_id = auth.uid())
  )
  with check (
    exists (select 1 from habits_v2 where id = habit_id and user_id = auth.uid())
  );
-- === END MIGRATION: 0001_habits_core.sql ===

-- === BEGIN MIGRATION: 0002_push.sql ===
-- ========================================================
-- HABITS MODULE - WEB PUSH NOTIFICATIONS
-- Migration 0002: Push Subscriptions
-- ========================================================

-- PUSH SUBSCRIPTIONS TABLE
create table if not exists public.push_subscriptions (
  user_id uuid not null references auth.users(id) on delete cascade,
  endpoint text primary key,
  p256dh text not null,
  auth text not null,
  created_at timestamptz default now()
);

-- RLS
alter table public.push_subscriptions enable row level security;

drop policy if exists "own push" on public.push_subscriptions;
create policy "own push" on public.push_subscriptions
  for all using (auth.uid() = user_id) with check (auth.uid() = user_id);
-- === END MIGRATION: 0002_push.sql ===

-- === BEGIN MIGRATION: 0003_challenges_autoprog.sql ===
-- ========================================================
-- HABITS MODULE - CHALLENGES & AUTO-PROGRESSION
-- Migration 0003: Challenges, Leaderboard, Auto-Progression
-- ========================================================

-- CHALLENGES TABLE
create table if not exists public.habit_challenges (
  id uuid primary key default gen_random_uuid(),
  owner_id uuid not null references auth.users(id) on delete cascade,
  title text not null,
  description text,
  start_date date not null,
  end_date date not null,
  scoring text not null default 'count', -- 'count' = #days done; 'sum' = sum(value)
  created_at timestamptz default now()
);

-- CHALLENGE MEMBERS TABLE
create table if not exists public.habit_challenge_members (
  id uuid primary key default gen_random_uuid(),
  challenge_id uuid not null references public.habit_challenges(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  habit_id uuid, -- optional link to a specific habit (references habits_v2)
  joined_at timestamptz default now(),
  unique (challenge_id, user_id)
);

-- Add foreign key for habit_id if habits_v2 exists
do $$
begin
  if exists (select 1 from information_schema.tables where table_schema = 'public' and table_name = 'habits_v2') then
    if not exists (
      select 1 from information_schema.table_constraints 
      where constraint_name = 'habit_challenge_members_habit_id_fkey' 
      and table_name = 'habit_challenge_members'
    ) then
      alter table public.habit_challenge_members add constraint habit_challenge_members_habit_id_fkey 
        foreign key (habit_id) references public.habits_v2(id) on delete set null;
    end if;
  end if;
end $$;

-- CHALLENGE LEADERBOARD VIEW
create or replace view public.v_challenge_scores as
select m.challenge_id,
       m.user_id,
       p.display_name as user_display_name,
       coalesce(
         case c.scoring
           when 'sum' then (select sum(value) from habit_logs_v2 l
                            where l.user_id=m.user_id
                              and (m.habit_id is null or l.habit_id=m.habit_id)
                              and l.date between c.start_date and c.end_date)
           else (select count(distinct l.date) from habit_logs_v2 l
                 where l.user_id=m.user_id
                   and (m.habit_id is null or l.habit_id=m.habit_id)
                   and l.done is true
                   and l.date between c.start_date and c.end_date)
         end
       ,0)::numeric as score
from habit_challenge_members m
join habit_challenges c on c.id=m.challenge_id
left join profiles p on p.user_id = m.user_id;

-- RLS
alter table public.habit_challenges enable row level security;
alter table public.habit_challenge_members enable row level security;

-- Challenge policies
drop policy if exists "owner or member read challenge" on public.habit_challenges;
create policy "owner or member read challenge" on public.habit_challenges
  for select using (
    auth.uid() = owner_id
    or exists(select 1 from habit_challenge_members m where m.challenge_id = habit_challenges.id and m.user_id = auth.uid())
  );

drop policy if exists "owner write challenge" on public.habit_challenges;
create policy "owner write challenge" on public.habit_challenges
  for all using (auth.uid() = owner_id) with check (auth.uid() = owner_id);

-- Member policies
drop policy if exists "member read" on public.habit_challenge_members;
create policy "member read" on public.habit_challenge_members
  for select using (
    auth.uid() = user_id 
    or auth.uid() = (select owner_id from habit_challenges where id=challenge_id)
  );

drop policy if exists "self upsert" on public.habit_challenge_members;
create policy "self upsert" on public.habit_challenge_members
  for insert with check (auth.uid() = user_id);

drop policy if exists "self delete" on public.habit_challenge_members;
create policy "self delete" on public.habit_challenge_members
  for delete using (
    auth.uid() = user_id 
    or auth.uid() = (select owner_id from habit_challenges where id=challenge_id)
  );
-- === END MIGRATION: 0003_challenges_autoprog.sql ===

-- === BEGIN MIGRATION: 0101_vision_core.sql ===
-- Ensure tz on profiles
do $$ begin
  alter table public.profiles add column if not exists tz text default 'UTC';
exception when others then null; end $$;

do $$
begin
  begin
    create type vb_board_type as enum ('vision','focus');
  exception when duplicate_object then
    null;
  end;
end$$;

do $$
begin
  begin
    create type vb_card_size as enum ('S','M','L','XL');
  exception when duplicate_object then
    null;
  end;
end$$;

create table if not exists public.vb_boards (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  title text not null,
  board_type vb_board_type not null default 'vision',
  theme jsonb default '{}'::jsonb,
  cover_card_id uuid,
  archived boolean default false,
  created_at timestamptz default now()
);

create table if not exists public.vb_sections (
  id uuid primary key default gen_random_uuid(),
  board_id uuid not null references public.vb_boards(id) on delete cascade,
  title text not null,
  sort_index int default 0
);

create table if not exists public.vb_cards (
  id uuid primary key default gen_random_uuid(),
  board_id uuid not null references public.vb_boards(id) on delete cascade,
  section_id uuid references public.vb_sections(id) on delete set null,
  user_id uuid not null references auth.users(id) on delete cascade,
  kind text not null default 'image',       -- 'image' | 'text'
  title text,
  affirm text,
  color text,
  tags text[] default '{}',
  size vb_card_size default 'M',
  favorite boolean default false,
  visible_in_share boolean default true,
  link_type text,                           -- 'habit' | 'goal' | null
  link_id uuid,
  img_path text,
  img_w int, img_h int,
  sort_index int default 0,
  created_at timestamptz default now()
);

create or replace view public.vb_board_stats as
  select b.id board_id,
         count(c.*) as card_count,
         coalesce(sum(case when c.favorite then 1 else 0 end),0) as favorite_count
  from vb_boards b
  left join vb_cards c on c.board_id=b.id
  group by b.id;

-- RLS
alter table public.vb_boards enable row level security;
alter table public.vb_sections enable row level security;
alter table public.vb_cards enable row level security;

drop policy if exists "own boards" on public.vb_boards;
create policy "own boards" on public.vb_boards
  for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

drop policy if exists "sections of own boards" on public.vb_sections;
create policy "sections of own boards" on public.vb_sections
  for all using (auth.uid() in (select user_id from vb_boards where id = board_id))
  with check (auth.uid() in (select user_id from vb_boards where id = board_id));

drop policy if exists "own cards" on public.vb_cards;
create policy "own cards" on public.vb_cards
  for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

do $$ begin perform gen_random_uuid(); exception when undefined_function then
  create extension if not exists pgcrypto; end $$;
-- === END MIGRATION: 0101_vision_core.sql ===

-- === BEGIN MIGRATION: 0102_sharing_push.sql ===
create table if not exists public.vb_shares (
  id uuid primary key default gen_random_uuid(),
  board_id uuid not null references public.vb_boards(id) on delete cascade,
  owner_id uuid not null references auth.users(id) on delete cascade,
  slug text unique not null,
  is_active boolean default true,
  created_at timestamptz default now()
);
alter table public.vb_shares enable row level security;
create policy "owner manage share" on public.vb_shares
  for all using (auth.uid() = owner_id) with check (auth.uid() = owner_id);

create table if not exists public.push_subscriptions (
  user_id uuid not null references auth.users(id) on delete cascade,
  endpoint text primary key,
  p256dh text not null,
  auth text not null,
  created_at timestamptz default now()
);
alter table public.push_subscriptions enable row level security;
create policy "own push" on public.push_subscriptions
  for all using (auth.uid() = user_id) with check (auth.uid() = user_id);
-- === END MIGRATION: 0102_sharing_push.sql ===

-- === BEGIN MIGRATION: 0103_gratitude_mood.sql ===
create table if not exists public.vb_checkins (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  board_id uuid references public.vb_boards(id) on delete set null,
  the_date date not null default current_date,
  mood int check (mood between 1 and 5),
  gratitude text,
  created_at timestamptz default now()
);

create unique index if not exists vb_checkins_user_date_board_idx
  on public.vb_checkins (user_id, the_date, coalesce(board_id, '00000000-0000-0000-0000-000000000000'::uuid));
alter table public.vb_checkins enable row level security;
create policy "own checkins" on public.vb_checkins
  for all using (auth.uid() = user_id) with check (auth.uid() = user_id);
-- === END MIGRATION: 0103_gratitude_mood.sql ===

-- === BEGIN MIGRATION: 0104_life_goals_extended.sql ===
-- Migration: Extended Life Goals with Steps, Substeps, and Alerts
-- This migration adds support for detailed life goals with steps, timing, and PWA notifications

-- Create life_goal_steps table for managing goal steps
create table if not exists public.life_goal_steps (
  id uuid primary key default gen_random_uuid(),
  goal_id uuid not null references public.goals (id) on delete cascade,
  step_order int not null default 0,
  title text not null,
  description text,
  completed boolean not null default false,
  completed_at timestamptz,
  due_date date,
  created_at timestamptz not null default timezone('utc', now())
);

-- Create life_goal_substeps table for managing substeps
create table if not exists public.life_goal_substeps (
  id uuid primary key default gen_random_uuid(),
  step_id uuid not null references public.life_goal_steps (id) on delete cascade,
  substep_order int not null default 0,
  title text not null,
  completed boolean not null default false,
  completed_at timestamptz,
  created_at timestamptz not null default timezone('utc', now())
);

-- Create life_goal_alerts table for managing goal alerts and notifications
create table if not exists public.life_goal_alerts (
  id uuid primary key default gen_random_uuid(),
  goal_id uuid not null references public.goals (id) on delete cascade,
  user_id uuid not null references auth.users (id) on delete cascade,
  alert_type text not null, -- 'milestone', 'deadline', 'reminder', 'custom'
  alert_time timestamptz not null,
  title text not null,
  message text,
  sent boolean not null default false,
  sent_at timestamptz,
  repeat_pattern text, -- 'once', 'daily', 'weekly', 'monthly'
  enabled boolean not null default true,
  created_at timestamptz not null default timezone('utc', now())
);

-- Add new columns to goals table for extended features
alter table public.goals
  add column if not exists life_wheel_category text,
  add column if not exists start_date date,
  add column if not exists timing_notes text,
  add column if not exists estimated_duration_days int;

-- Create index for faster queries
create index if not exists life_goal_steps_goal_id_idx on public.life_goal_steps (goal_id);
create index if not exists life_goal_substeps_step_id_idx on public.life_goal_substeps (step_id);
create index if not exists life_goal_alerts_goal_id_idx on public.life_goal_alerts (goal_id);
create index if not exists life_goal_alerts_user_id_idx on public.life_goal_alerts (user_id);
create index if not exists life_goal_alerts_alert_time_idx on public.life_goal_alerts (alert_time);
create index if not exists goals_life_wheel_category_idx on public.goals (life_wheel_category);

-- Add RLS policies for life_goal_steps
alter table public.life_goal_steps enable row level security;

create policy "Users can view steps for their own goals"
  on public.life_goal_steps for select
  using (
    exists (
      select 1 from public.goals
      where goals.id = life_goal_steps.goal_id
      and goals.user_id = auth.uid()
    )
  );

create policy "Users can insert steps for their own goals"
  on public.life_goal_steps for insert
  with check (
    exists (
      select 1 from public.goals
      where goals.id = life_goal_steps.goal_id
      and goals.user_id = auth.uid()
    )
  );

create policy "Users can update steps for their own goals"
  on public.life_goal_steps for update
  using (
    exists (
      select 1 from public.goals
      where goals.id = life_goal_steps.goal_id
      and goals.user_id = auth.uid()
    )
  );

create policy "Users can delete steps for their own goals"
  on public.life_goal_steps for delete
  using (
    exists (
      select 1 from public.goals
      where goals.id = life_goal_steps.goal_id
      and goals.user_id = auth.uid()
    )
  );

-- Add RLS policies for life_goal_substeps
alter table public.life_goal_substeps enable row level security;

create policy "Users can view substeps for their own goals"
  on public.life_goal_substeps for select
  using (
    exists (
      select 1 from public.life_goal_steps
      join public.goals on goals.id = life_goal_steps.goal_id
      where life_goal_steps.id = life_goal_substeps.step_id
      and goals.user_id = auth.uid()
    )
  );

create policy "Users can insert substeps for their own goals"
  on public.life_goal_substeps for insert
  with check (
    exists (
      select 1 from public.life_goal_steps
      join public.goals on goals.id = life_goal_steps.goal_id
      where life_goal_steps.id = life_goal_substeps.step_id
      and goals.user_id = auth.uid()
    )
  );

create policy "Users can update substeps for their own goals"
  on public.life_goal_substeps for update
  using (
    exists (
      select 1 from public.life_goal_steps
      join public.goals on goals.id = life_goal_steps.goal_id
      where life_goal_steps.id = life_goal_substeps.step_id
      and goals.user_id = auth.uid()
    )
  );

create policy "Users can delete substeps for their own goals"
  on public.life_goal_substeps for delete
  using (
    exists (
      select 1 from public.life_goal_steps
      join public.goals on goals.id = life_goal_steps.goal_id
      where life_goal_steps.id = life_goal_substeps.step_id
      and goals.user_id = auth.uid()
    )
  );

-- Add RLS policies for life_goal_alerts
alter table public.life_goal_alerts enable row level security;

create policy "Users can view their own goal alerts"
  on public.life_goal_alerts for select
  using (user_id = auth.uid());

create policy "Users can insert their own goal alerts"
  on public.life_goal_alerts for insert
  with check (user_id = auth.uid());

create policy "Users can update their own goal alerts"
  on public.life_goal_alerts for update
  using (user_id = auth.uid());

create policy "Users can delete their own goal alerts"
  on public.life_goal_alerts for delete
  using (user_id = auth.uid());

-- Add comments for documentation
comment on table public.life_goal_steps is 'Steps for breaking down life goals into actionable tasks';
comment on table public.life_goal_substeps is 'Substeps for further breaking down goal steps';
comment on table public.life_goal_alerts is 'Alert and notification schedules for life goals (PWA compatible)';
comment on column public.goals.life_wheel_category is 'Links goal to a life wheel category (spirituality_community, finance_wealth, etc.)';
comment on column public.goals.start_date is 'When the user plans to start working on this goal';
comment on column public.goals.timing_notes is 'Detailed timing and schedule notes for the goal';
comment on column public.goals.estimated_duration_days is 'Estimated number of days to complete this goal';
-- === END MIGRATION: 0104_life_goals_extended.sql ===

-- === BEGIN MIGRATION: 0105_vision_images_url_support.sql ===
-- Add support for URL-based images in vision_images table
-- This migration adds columns to support both file uploads and external URLs

-- Add image_url column to store external image URLs
alter table public.vision_images add column if not exists image_url text;

-- Add image_source column to track whether the image is from a file or URL
-- Default to 'file' for backward compatibility with existing records
alter table public.vision_images add column if not exists image_source text default 'file';

-- Add check constraint to ensure image_source is either 'file' or 'url'
do $$ 
begin
  if not exists (
    select 1 from pg_constraint 
    where conname = 'vision_images_source_check' 
    and conrelid = 'public.vision_images'::regclass
  ) then
    alter table public.vision_images 
    add constraint vision_images_source_check 
    check (image_source in ('file', 'url'));
  end if;
end $$;

-- Add check constraint to ensure either image_path or image_url is set based on source
do $$ 
begin
  if not exists (
    select 1 from pg_constraint 
    where conname = 'vision_images_path_url_check' 
    and conrelid = 'public.vision_images'::regclass
  ) then
    alter table public.vision_images 
    add constraint vision_images_path_url_check 
    check (
      (image_source = 'file' and image_path is not null) or
      (image_source = 'url' and image_url is not null)
    );
  end if;
end $$;

-- Comment the columns for documentation
comment on column public.vision_images.image_url is 'External URL for images loaded from the web';
comment on column public.vision_images.image_source is 'Source type: file (uploaded to storage) or url (external link)';
-- === END MIGRATION: 0105_vision_images_url_support.sql ===
